# 第一章 计算机系统概述

## 计算机发展历程

### 什么是计算机系统

计算机系统 = 硬件 + 软件, 计算机性能的好坏取决于“软”、“硬”件功能的总和

### 软件

- 系统软件: 用来管理整个计算机系统, 如操作系统、数据库管理系统、标准程序库(API)、网络软件、语言处理程序(高级语言变机器语言)、服务程序
- 应用软件: 按任务需要编制成的各种程序, 如抖音、王者荣耀、迅雷、美图秀秀

### 硬件的发展

| 发展阶段 | 时间      | 逻辑元件                 | 速度(次/秒)   | 内存           | 外存                           |
| -------- | --------- | ------------------------ | ------------- | -------------- | ------------------------------ |
| 第一代   | 1946-1957 | 电子管                   | 几千-几万     | 贡延迟线、磁鼓 | 穿孔卡片、纸带                 |
| 第二代   | 1958-1964 | 晶体管                   | 几万-几十万   | 磁芯存储器     | 磁带                           |
| 第三代   | 1964-1971 | 中小规模集成电路         | 几十万-几百万 | 半导体存储器   | 磁带、磁盘                     |
| 第四代   | 1972-现在 | 大规模、超大规模集成电路 | 上千万-万亿   | 半导体存储器   | 磁带、磁盘、光盘、半导体存储器 |

#### 微处理器的发展

- 机器字长: 计算机一次整数运算所能处理的二进制位数
- 微型计算机的发展以微处理器技术为标志

#### 硬件发展历史

- 1947年, 贝尔实验室, 威廉・肖克利发明“晶体管”
- 1955年, 肖克利在硅谷创建肖克利实验室股份有限公司
- 1957年, 八叛徒创立仙童半导体公司
- 1959年, 仙童半导体公司发明“集成电路”
- 1968年, 摩尔等人离开仙童, 创立intel
- 1969年, 仙童销售部负责人桑德斯离开仙童, 创立AMD

#### 摩尔定律

集成电路上可容纳的晶体管数目, 约每隔18个月会增加一倍, 整体性能也将增加一倍

### 软件的发展

#### 编程语言的发展

1. 机器语言/汇编语言
2. FORTRAN
3. PASCAL
4. C++
5. Java

#### 操作系统的发展

1. DOS
2. windows、ios、macos、android

### 目前发展趋势

- 向更微型化、网络化、高性能、多用途方向发展
- 向巨型化、超高速、并行处理、智能化方向发展

## 计算机硬件的基本组成

### 冯诺依曼结构

#### 存储程序

- 存储程序: 指将指令以二进制代码的形式事先输入计算机的主存储器, 然后按其在存储器中的首地址执行程序的第一条命令, 以后就按该程序的规定顺序执行其他的命令, 直至程序执行结束

#### 流程

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Computer%20system%20overview/IMG/The%20basic%20composition%20of%20computer%20hardware1.png)

#### 特点

1. 计算机由五大部件组成: I/O设备、存储器、运算器、控制器
2. 指令和数据以同等地位位于存储器, 可以按地址寻访
3. 指令和数据用二进制表示
4. 指令由操作码和地址码组成
5. 存储程序
6. 以运算器为中心(输入/输出设备与存储器之间的数据传送通过运算器完成)

### 现代计算机的结构

- 以存储器为中心
- CPU = 运算器 + 控制器
  
#### 流程

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Computer%20system%20overview/IMG/The%20basic%20composition%20of%20computer%20hardware2.png)

- “主机”指的是CPU+主存储器
- “辅存”指的是机械硬盘等等

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Computer%20system%20overview/IMG/The%20basic%20composition%20of%20computer%20hardware3.png)

### 存储器的层次结构

- 寄存器: CPU中的存储器, 少量但是速度很快
- 高速缓冲存储器: 介于CPU和主存之间, 称为“Cache”
- 主存: 即通常所说的内存条

## 硬件部件

### 主存储器的基本组成

![](https://github.com/Ricolxwz/Computer-Organization/blob/c74d7fc03529c7e1654a4c23379fc502d187f54c/Computer-Organization%20WD/Computer%20system%20overview/IMG/Main%20memory1.png)

- MAR位数反映存储单元的个数
- MDR位数 = 存储字长
- 字和字节是不一样的!

#### 存储体

- 存储单元: 每个存储单元存放一串二进制代码
- 存储元件(存储元): 每个存储单元包含若干存储元件, 每个存储元件存储一位二进制代码
- 存储子: 存储单元中二进制代码的组合
- 存储字长: 存储单元中二进制代码的位数, 应该是8bit的整数倍

### 运算器的基本组成

![](https://github.com/Ricolxwz/Computer-Organization/blob/c74d7fc03529c7e1654a4c23379fc502d187f54c/Computer-Organization%20WD/Computer%20system%20overview/IMG/Arithmetic%20unit1.png)

- 运算器: 用于实现算数运算、逻辑运算
- ACC: 累加器, 用于存放操作数, 或者运算结果
- MQ: 乘商寄存器, 在乘、除运算时, 用于存放操作数或者运算结果
- X: 通用的操作数寄存器, 用于存放操作数
- ALU: 算术逻辑单元, 通过内部复杂的电路实现算数运算、逻辑运算

|                                | 加     | 减         | 乘             | 除           |
| ------------------------------ | ------ | ---------- | -------------- | ------------ |
| ACC(Accumulator)               | 被加数 | 被减数、差 | 乘积高位       | 被除数、余数 |
| MQ(MUltiple-Quotient Register) |        |            | 乘数、乘积低位 | 商           |
| X(Arithmetic and Logic Unit)   | 加数   | 减数       | 被乘数         | 除数         |

### 控制器的基本组成

![](https://github.com/Ricolxwz/Computer-Organization/blob/c74d7fc03529c7e1654a4c23379fc502d187f54c/Computer-Organization%20WD/Computer%20system%20overview/IMG/Controller1.png)

- CU(Control Unit): 控制单元, 分析指令, 给出控制信号
- IR(Instruction Register): 指令寄存器, 存放当前执行的指令
- PC(Program Counter): 程序计数器, 存放下一条指令的地址, 有自动加1的功能

#### 完成一条指令

1. 取指令: PC
2. 存放指令: IR
3. 分析、执行指令: CU

### 计算机的工作过程

![](https://github.com/Ricolxwz/Computer-Organization/blob/c74d7fc03529c7e1654a4c23379fc502d187f54c/Computer-Organization%20WD/Computer%20system%20overview/IMG/work%20process1.png)

1. 最初: (PC)=0, 指向第一条指令的存储地址
2. #1: (PC)->MAR, 导致(MAR)=0
3. #3: M(MAR)->MDR, 导致MDR=000001 0000000101
4. #4: (MDR)->IR, 导致(IR)=000001 0000000101
5. #5: OP(IR)->CU, 指令的操作码送到CU, CU分析后得知, 是“取数”指令
6. #6: Ad(IR)->MAR, 指令的地址码送到MAR, 导致(MAR)=5
7. #8: M(MAR)->MDR, 导致(MDR)=0000000000000010=2
8. #9: (MDR)->ACC, 导致ACC=0000000000000010=2
9. 上一条指令取后PC自动加1, 以上为“取数”指令执行过程. 其他指令自行分析

- M: 主存中某存储单元
- ACC、MQ、X、MAR、MDR: 相应寄存器
- M(MAR): 取存储单元中的数据
- (ACC): 取相应寄存器中的数据
- 指令: 操作码+地址码
- OP(IR): 取操作码
- Ad(IR): 取地址码

## 计算机的层次结构

### 层次结构

![](https://github.com/Ricolxwz/Computer-Organization/blob/627156e24c745225017b428b6e95285180c849f5/Computer-Organization%20WD/Computer%20system%20overview/IMG/Multi-level%20hierarchical%20structure%20of%20computer%20system1.png)

- M0: 由硬件直接执行微指令
- M1: 执行二进制机器指令
- M2: 向上提供“广义指令”, 由操作系统程序实现, 由机器指令和广义指令组成, 目的是为了扩展机器功能, 也称为混合层
- M3: 用汇编程序翻译成机器语言程序
- M4: 用编译程序翻译成汇编语言程序

### 三种级别的语言

![](https://github.com/Ricolxwz/Computer-Organization/blob/main/Computer-Organization%20WD/Computer%20system%20overview/IMG/Computer%20hierarchy1.png)

#### 编译程序和解释程序的区别

- 编译程序: 将高级语言编写的源程序全部语句一次全部翻译成机器语言程序, 而后再执行机器语言程序(只需要翻译一次)
- 解释程序: 将源程序的一条语句翻译成对英语机器语言的语句, 并立即执行. 紧接着再翻译下一句(每次执行都需要翻译)

## 计算机性能指标

### 存储器的性能指标

#### 总容量

- 总容量 = 存储单元的个数 * 存储字长 bit = 存储单元个数 * 存储字长/8 Byte
- MAR: 位数反映存储单元的个数(最多支持多少个)
- MDR: 位数=存储字长=每个存储单元的大小

例如: MAR32为, MDR8位, 总容量=2^32*8bit=4GB

### CPU的性能指标

#### 主频

- CPU主频: CPU内数字脉冲信号振荡的频率
- 在描述CPU主频的时候, “G”指的是10^9

#### 时钟周期

- 时钟周期: 每个脉冲的时间
- CPU主频=1/时钟周期

#### CPI(Clock Cycle Per Instruction)

- CPI(Clock Cycle Per Instruction): 执行一条指令所需的时钟周期数, 不同的指令, CPI不同. 甚至相同的指令, CPI也有可能变化(在CPU内部实现方式不同)
- 执行一条指令消耗的时间=CPI*时钟周期
- CPU执行时间(整个程序消耗的时间)=CPU时钟周期数/主频=(指令条数*CPI)/主频

例如: 某CPU的主频为1000Hz, 某程序包含100条指令, 平均来看指令的CPI=3. 该程序在CPU上执行需要多长时间? 1000*3*1/1000=0.3s

#### IPS(Instruction Per Second)

- IPS(Instruction Per Second): 每秒执行多少条指令
- IPS=主频/平均CPI

#### FLOPS(FLoating-point Operations Per Second)

- FLOPS(FLoating-point Operations Per Second): 每秒执行多少次浮点运算

### 系统整体性能指标

#### 数据通路带宽

- 数据通路带宽: 数据总线一次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)

#### 吞吐量

- 吞吐量: 指系统在单位时间内处理请求的数量

#### 相应时间

- 相应时间: 指从用户向计算机发送一个请求, 到系统对该请求做出相应并获得它所需要的结果的等待时间

### 系统整体的性能指标(动态测试)

#### 基准程序

- 基准程序: 用来测量计算机处理速度的一种实用程序, 以便于被测量的计算机性能可以与运行相同程序的其他计算机的性能进行比较

### 一些思考

- 主频高的CPU一定比主频低的CPU快吗? 
  - 不一定, 如两个CPU, A的主频是2GHz, 平均CPI=10; B的主频为1GHz, 平均CPI=1; 则A的IPS为0.2G, B的IPS为1G
- 若上述A和B两个CPU的平均CPI相同, 则A一定更快吗?
  - 不一定, 还要看指令系统, 如A不支持乘法指令, 只能用多次的加法实现惩乘法; 而B支持乘法指令
- 基准程序执行得越快说明机器的性能越好吗?
  - 不一定, 基准程序中的语句存在频度差异, 运行结果也不能完全说明问题

# 第二章 数据的表示和运算

## 进位计数制

### r进制计数法

- r进制: $K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}+...+K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}+...+K_{-m}\times r^{-m}$
- 基数: 每个数码位所用到的不同符号的个数, r进制的基数为r 

### 任意进制转十进制

- $K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}=K_n\times r^n+K_{n-1}\times r^{n-1}+...+K_2\times r^2+K_1\times r^1+K_0\times r^0+K_{-1}\times r^{-1}+K_{-2}\times r^{-2}+...+K_{-m}\times r^{-m}$

### 二进制转八进制和十六进制

- 二进制转八进制: 3位为一组, 每组转换成对应的八进制符号
- 二进制转十六进制: 4位为一组, 每组转换成对应的十六进制符号

### 八进制和十六进制转二进制

- 八进制转二进制: 每位八进制对应3位二进制
- 十六进制转二进制: 每位十六进制对应4位二进制

### 常用进制的书写方式

- 二进制: $(1010101000001010)_2\quad 1010101000001010B$
- 八进制: $(1652)_8$
- 十六进制: $(1652)_{16}\quad 1652H\quad Ox1652$
- 十进制: $(1652)_{10}\quad 1652D$

### 十进制转化为任意进制

#### 除基取余法证明(整数部分)

1. $\frac{K_n\times r^n+K_{n-1}\times r^{n-1}+...+K_2\times r^2+K_1\times r^1+K_0\times r^0}{r}=K_n\times r^{n-1}+K_{n-1}\times r^{n-2}+...+K_2\times r^1+K_1\times r^0...K_0$(余数)
2. 令$K_n\times r^{n-1}+K_{n-1}\times r^{n-2}+...+K_2\times r^1+K_1\times r^0=x$
3. $K_n\times r^n+K_{n-1}\times r^{n-1}+...+K_2\times r^2+K_1\times r^1+K_0\times r^0$可表示为$rx+K_0$
4. 由于$K_0∊[0, r-1], 所以\frac{rx+K_0}{r}$所得的商为$x$, 余数为$K_0$
5. 用得到的商除以r, 依次得到余数$K_n$

#### 乘积取整法证明(小数部分)

1. $(K_{-1}\times r^{-1}+K_{-2}\times r^{-2}+...+K_{-m}\times r^{-m})\times r=K_{-1}\times r^{0}+K_{-2}\times r^{-1}+...+K_{-m}\times r^{-(m-1)}$
2. 得到的整数部分$K_{-1}\times r^{0}$为$K_{-1}$的值
3. 将剩下的小数部分$K_{-2}\times r^{-1}+...+K_{-m}\times r^{-(m-1)}$乘以$r$, 得到$K_{-2}$的值
4. 用得到的小数部分乘以$r$, 依次得到$K_{-m}$

若小数部分的无论经过多少次的乘法都无法得到准确的二进制表示, 则要保留一定的精度(不是每个十进制的小数都能用二进制精确的表示, 但是任意一个二进制的小数都可以用十进制小数表示)

### 真值和机器数

在计算机中, 常常采用数的符号和数值一起编码的方法来表示数据. 常用的有原码、反码、补码、移码

- 真值: 复合人类习惯的数字
- 机器数: 数字实际存到机器里面的形式, 正负号需要被“数字化”

## BCD码(Binary-Coded Decimal)

BCD码通常采用4位二进制数来表示一位十进制数中的0-9这10个数码. 但4位二进制数可以组合出16种代码, 因此必有6种状态为冗余状态

### 8421码

映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

如“985”对应的8421码为100110000101

#### 加法运算

- 手算: 可以先将8421码转化为十进制, 再将十进制运算结果转化为8421码
- 机算: 如果二进制加法的结果落在1010-1111中(10-15中), 在运算的结果上再加上6

### 余3码

8421码+(0011)2, 映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |


### 2421码

改变权值定义, 映射关系:

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

特点: 大于等于5的4位二进制数中的最高位为1, 小于5的最高位为0. 如5->1011而非0101

## 字符与字符串

### ASCII码

- 将数字、字母、符号共128个字符用7位二进制编码表示
- 可印刷字符: 32-126, 其余为控制、通信字符

### 汉字的表示和编码

#### GB 2312-80

- 汉字+各种符号共7445个
- 区位码: 用两个字节表示一个汉字, 每字节用七位码, 并将汉字和图形符号排列在一个94行94列的二维代码表中. 区位码是4位十进制数, 前2位是区码, 后2位是位码
- 国标码 = (区位码)16 + 2020H
- 汉字内码 = (国标码)16 + 8080H

#### 为什么要加上2020H和8080H

<https://blog.csdn.net/zrf2112/article/details/50718684>

- 为啥要将区位码转化为国标码?
  - 汉字编码之前, 已经有了标准的ASCII, 开发者只沿用了ASCII中32个控制字符其他ASCII被覆盖. 通过32D=20H的关系, 不难发现, 加上2020H是为了绕开ASCII的控制字符
- 为啥要将国标码转化为机内码?
  - 国标码中除了前面32个控制字符外, 其他ASCII内容被覆盖, 这使得使用者在使用采用ASCII码编码的网页或者文本内容时不能兼容, 只能看到乱码. 为了解决这个问题要在国标码的基础上补充ASCII的32个控制字符外的其他字符. 已知道标准的ASCII码最高位为0, 国标码的最高位也是0. 那么只需要在国标码的基础上将最高位改为1即可. 通过10000000B=80H的关系, 不难发现, 加上8080H是为了在国标码基础上解决ASCII字母等符号的兼容性问题

#### 流程

- 输入: 输入编码, 如“内”汉字, 举个例子, 输入编码为“nei2”, 将输入编码转化为国标码, 在通过系统软件将国标码转化为机内码存储在计算机中
- 输出: 汉字字形码. 先将机内码转化为国标码, 再转化为字形码

### 字符串

1. 某计算机按字节编址(每个字节对应1B), 从地址为2的单元开始, 存储字符串“abc”

|     |     | 61H | 62H | 63H | 00H |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

很多语言中, 将'\0'作为字符串结束的标志

2. 某计算机按字节编址(每个字节对应1B), 从地址为2的单元开始, 存储字符串“abc啊”. “啊”的机内码为B0 A1H

在所有计算机中, 多字节数据都被存放在连续的字节序列中. 根据数据中各字节排列顺序的不同, 可能有“大端模式”和“小端模式”

- 大端模式: 将数据的最高有效字节存放在低地址单元中

|     |     | 61H | 62H | 63H | 00H | B0H | A1H | 00H |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

- 小端模式: 将数据的最高有效字节存放在高地址单元中

|     |     | 61H | 62H | 63H | 00H | A1H | B0H | 00H |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

## 奇偶校验码

### 校验原理简介

- 2bit映射到4个合法状态

| 信息 | A   | B   | C   | D   |
| ---- | --- | --- | --- | --- |
| 编码 | 00  | 01  | 10  | 11  |

- 3bit映射到4个合法状态(有4个冗余的非法状态)

| 信息 | A   | B   | C   | D   |
| ---- | --- | --- | --- | --- |
| 编码 | 100 | 001 | 010 | 111 |

- 由若干位代码组成的一个字叫做码字
- 将两个码字逐位进行对比, 具有不同的位的个数称为两个码字间的距离
- 一种编码方案可能有若干个合法的码字, 各合法的码字间的最小距离为“码距”. 如第一种情况, 码距为1, 即改变1位二进制位就有可能从一个合法的码字转变为另一个合法的码字; 第二种情况, 码距为2, 即改变1位二进制位只能使得从一个合法的码字转变为一个非法的码字.
- 当码距d=1时, 无检错能力; 当d=2时, 有检错能力; 当d≥3时, 若设计合理, 可能具有检错、纠错能力

### 奇偶检验法

- 整个校验码(有效信息位和校验位)中“1”的个数为奇数
- 整个校验码(有效信息位和校验位)中“1”的个数为偶数

![](https://github.com/Ricolxwz/Computer-Organization/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Parity%20check%20code1.png)

> Q: 给出两个编码1001101和1010111的奇检验码和偶检验码
> <br> 设最高位为奇校验位, 余7位为信息位,则对应的奇偶检验码为:
> - 奇检验: **1**1001101; **0**1010111
> - 偶校验: **0**1001101; **1**1010111

- 偶检验的硬件实现: 第一步, 各个信息进行异或(模2加)运算, 得到的课结果即为偶检验位. 第二步, 进行偶校验, 所有的位进行异或, 若结果为1说明出错

## 海明校验码

### 思路简介

- 偶检验: 1010 -> 01010, 能发现奇数位错误, 但无法确定是哪一位出错
- 海明码设计思路: 将信息位分组进行偶检验 -> 多个校验位

### 求解步骤

1. 确定海明吗的位数
2. 确定校验位的分布
3. 求校验位的值
4. 纠错

#### 确定海明码的位数

设n为有效信息位位数, k位校验位位数, 校验位有2^k种状态, 信息位加检验位共n+k位, 出错的情况有n+k种(1位出错), 成功的情况有1种. 所以k和n的关系应该满足: $2^k≥n+k+1$

#### 确定校验位的分布

校验位Pi放在海明位号为$2^{i-1}$的位置上

#### 求校验位的值

将信息位所处的位置转换为二进制数. 将校验位所处的位置理解为权重, 通过异或运算得出校验位的值(基于偶校验)

#### 纠错

将分组中的值进行异或运算, 如果没有出错的话, 得到的结果应该是0(基于偶校验)

### 海明码的检错、纠错能力

- 纠错能力 -- 1位
- 检错能力 -- 2位

> 信息位: 1010
> 1. 确定位数: $2^k≥n+k+1$ n=4 -> k=3
> <br> 设信息位D4D3D2D1, 校验位P3P2P1, 对应的海明码为H7H6H5H4H3H2H1
> 2. 确定校验位的分布
> 
> | H7  | H6  | H5  | H4  | H3  | H2  | H1  |
> | --- | --- | --- | --- | --- | --- | --- |
> | D4  | D3  | D2  | P3  | D1  | P2  | P1  |
> | 1   | 0   | 1   |     | 0   |     |     |
> 3. 求校验位的值
> <br> H3: 3 -> 011
> <br> H5: 5 -> 101
> <br> H6: 6 -> 110
> <br> H7: 7 -> 101
> <br> $P_1=H_3\oplus H_5\oplus H_7=D_1\oplus D_2\oplus D_4=0$
> <br> $P_2=H_3\oplus H_6\oplus H_7=D_1\oplus D_3\oplus D_4=1$
> <br> $P_3=H_5\oplus H_5\oplus H_7=D_2\oplus D_3\oplus D_4=0$
> 
> | H7  | H6  | H5  | H4  | H3  | H2  | H1  |
> | --- | --- | --- | --- | --- | --- | --- |
> | D4  | D3  | D2  | P3  | D1  | P2  | P1  |
> | 1   | 0   | 1   |0    | 0   |1    |0    |
> 4. 纠错
> <br> 校验方程:
> <br> $S_1=P_1\oplus D_1\oplus D_2 \oplus D_4$
> <br> $S_2=P_2\oplus D_1\oplus D_3 \oplus D_4$
> <br> $S_3=P_3\oplus D_2\oplus D_3 \oplus D_4$
> <br> 接收到: 1010010
> <br> $S_1=P_1\oplus D_1\oplus D_2 \oplus D_4=0$
> <br> $S_2=P_2\oplus D_1\oplus D_3 \oplus D_4=0$
> <br> $S_3=P_3\oplus D_2\oplus D_3 \oplus D_4=0$
> <br> 故无错误
> <br> 接收到: 1010000
> <br> $S_1=P_1\oplus D_1\oplus D_2 \oplus D_4=0$
> <br> $S_2=P_2\oplus D_1\oplus D_3 \oplus D_4=1$
> <br> $S_3=P_3\oplus D_2\oplus D_3 \oplus D_4=0$
> <br> 故第010位出错
> <br> ![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Hamming%20check%20code1.png)
> 5. 全校验位
> <br> S3S2S1=000且全体偶校验成功->无错误
> <br> S3S2S1≠000且全体偶校验失败->有1位错误, 纠正即可
> <br> S3S2S1≠000且全体偶校验成功->有2位错误, 需要重新传输
> 
> | H8  | H7  | H6  | H5  | H4  | H3  | H2  | H1  |
> | --- | --- | --- | --- | --- | --- | --- | --- |
> | P全  | D4  | D3  | D2  | P3  | D1  | P2  | P1  |
> | 1   | 1   | 0   | 1   |0    | 0   |1    |0    |

## 循环冗余校验码

### 基本思想

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code1.png)

数据发送、接受方约定一个“除数”, K个信息位+R个校验位作为“被除数”, 添加校验位后需要保证除法的余数为0. 收到数据后, 进行除法检查余数是否为0. 若余数非0说明出错, 则进行重传或者纠错

### 步骤

#### 移位

将原信息码左移R位, 低位补0

#### 相除

- 对移位后的信息码, 用生成的多项式进行模2除法, 产生余数, 得到的余数就是校验码
- 模2除法: 模2加法和模2减法的结果相同, 都是异或运算. 模2除法和算数除法类似, 但每位除(减)的结果不影响其他位, 步骤如下: ①用除数对被除数最高几位做模2减运算(异或)不错位; ②除数右移1位, 若余数的最高位为1, 商为1, 并对余数做模2减运算. 若余数最高位为0, 商为0, 余数继续右移1位; ③ 循环直到余数位数小于余数时, 该余数为最终余数.

#### 检错和纠错

- 将接收端收到的CRC码, 用生成多项式G(x)做模2除法, 若余数为0, 则码字无错
- K个信息位, R个校验位, 若生成多项式选择得当, 且$2^R≥K+R+1$, 则CRC码可以纠正1位错(无法纠正的情况, 看下面例子)
- 在实际应用当中, 这种校验码一般只用来检错, 因为信息位实在是太长了
- 理论上可以证明循环冗余校验码的检错能力有以下几点:
  - 可检测出所有奇数个错误
  - 可检测出所有双比特的错误
  - 可检测出所有小于等于校验长度的连续错误

> Q: 设生成多项式为$G(x)=x^3+x^2+1$, 信息码为101001, 求对应的CRC码
> <br> R=生成多项式的最高幂次=3, K=信息码的长度=6, N=K+R=9
> <br> 生成多项式G(x)对应的二进制码为1101
> 1. 移位
> <br> 将原信息码左移R位, 低位补0, 得到了101001000
> 2. 相除
> <br> ![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code2.png)
> <br> 最终得到的余数为001, 则CRC码为101001001
> 3. 检错和纠错
> <br> 发送: 101001001 记为C9C8C7C6C5C4C3C2C1
> <br> 接收: 101001001 用1101进行模2除 余数为000, 代表没有出错
> <br> 接收: 101001011 用1101进行模2除 余数位010, 代表C2出错
> <br>
> <br> 注意: 余数为010并不一定代表C2出错
> <br> ![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code3.png)
> <br> 3个bit位最多只能表示8种状态(注意这里的出错位不是余数二进制转十进制!), 000表示正确状态. 从表中可以看出, 如果第9位出错的话, 余数也为010. 但不能说CRC码没有纠错能力, 只是本例中的信息位太长

## 定点数的表示

### 定点数和浮点数

- 定点数: 小数点的位置固定
- 浮点数: 小数点的位置不固定

### 无符号数的表示

- 无符号数: 整个机器字长的全部二进制位为数值位, 没有符号位, 相当于数的绝对值
- n位二进制数能够表示的范围: $2^n-1$, 有$2^n$种不同的状态
- 通常只有无符号整数, 而没有无符号小数

### 有符号数的表示

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Fixed-point%20representation1.drawio.svg)

- 可用原码、反码、补码三种方式来表示定点整数和定点小数, 还可以用移码表示定点整数
- 若真值为x, 则用[x]原、[x]反、[x]补、[x]移分别表示真值对应的原码、反码、补码、移码
- 注意: 顶点小数是纯小数, 顶点整数是纯整数

### 原码

原码: 用尾数表示真值的绝对值, 符号位"0/1"对应"正/负"

> 表示+19D
> 
> |0|0|0|1|0|0|1|1|
> |-|-|-|-|-|-|-|-|
> 
> 表示-19D
>
> |1|0|0|1|0|0|1|1|
> |-|-|-|-|-|-|-|-|
> 
> 常写为[x]原=1, 0010011
> <br> 如果未指明机器字长, 也可以写为[x]原=1, 10011
> 
> 表示+0.75D
>
> |0|1|1|0|0|0|0|0|
> |-|-|-|-|-|-|-|-|
> 
> 表示-0.75D
> 
> |1|1|1|0|0|0|0|0|
> |-|-|-|-|-|-|-|-|
> 
> 常写为: [x]原=1.1100000

#### 表示范围

真值0有两种表示形式: +0和-0

- 原码整数: 若机器字长为$n+1$位, 原码整数的表示范围: $-(2^n-1)\leq x \leq 2^n-1$(关于原点对称). ($n+1$个字节总共能表示的状态的个数为$2^{n+1}$个, 但实际只能表示$2^{n+1}-1$个数, 原因就是真值0有两种表示形式)
- 原码小数: 若机器字长为$n+1$位, 原码小数的表示范围: $-(1-2^{-n})\leq x\leq 1-2^{-n}$(关于原点对成)

### 反码

- 若符号位为0, 则反码与原码相同
- 若符号位为1, 则数值位全部取反

#### 表示范围

真值0有+0和-0两种形式
<br> [+0]原=00000000 [-0]原=10000000
<br> [+0]反=00000000 [-0]反=11111111

- 反码整数: 若机器字长$n+1$位, 反码整数的表示范围: $-(2^n-1)\leq x\leq 2^n-1$(关于原点对称)
- 反码小数: 若机器字长$n+1$位, 反码小数的表示范围: $-(1-2^{-n})\leq x\leq 1-2^{-n}$(关于原点对称)

### 补码

- 正数的补码=原码
- 负数的补码=反码末位+1(要考虑进位)
- 将负数补码转回原码的方法相同, 尾数取反, 末位+1

#### 表示范围

真值0的补码形式是唯一的, [+0]补=[-0]补=00000000
<br> 定点整数补码[x]补=1, 0000000表示$x=2^7$
<br> 定点小数补码[x]补=1. 0000000表示$x=-1$

- 补码整数: 若机器字长为$n+1$位, 补码整数的表示范围: $-2^n\leq x\leq 2^n-1$(比原码多表示一个$-2^n$)
- 补码小数: 若机器字长为$n+1$位, 补码小数的表示范围: $-1\leq x\leq 1-2^{-n}$(比原码多表示一个$-1$)

### 移码

移码: 补码的基础上将符号位取反. 注意: 移码只能适用于表示整数

#### 表示范围

移码的真值0和补码一样只有一种表示形式, [+0]移=[-0]移=10000000

- 移码整数: 若机器字长为$n+1$位, 移码整数的表示范围: $-2^n\leq x\leq 2^n-1$(与补码相同)

#### 作用

移码保持了数据原有的大小顺序, 移码大真值就大, 移码小真值就小

### 用几种码表示定点整数

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Fixed-point%20representation2.png)

## 各种码的作用

### 加减运算

使用原码运算:

- 加法: 用加法器完成
- 减法: 用减法器完成

由于减法器的电路结构复杂, 所以一般用加法代替减法运算

### 模运算的性质

- 带余除法: 设x, m∊Z, m>0则存在唯一确定的整数q和r, 使得: x=qm+r, 0≤r<m
- 在(mod m)的条件下, 若能找到负数的补数, 就可以用正数的加法等价替代减法
- 设a为负数, 则a的补数(其实就是a的补码)+a的绝对值=模

> -3mod12=9, 因为-3=(-1)*12+9
> <br> 9mod12=9
> <br> 21mod12=9
> <br> 33mod12=9
> <br> -15mod12=9
> 
> <br> (mod 12)把所有整数分为12类(余数为0~11)
> <br> mod 12余数相同的数, 都是同一类, 都是等价的
> <br> 即10+(-3)、10+9、10+21...在(mod 12)的条件下效果相同
> <br> -3和9互为**补数**, 二者的绝对值之和=模

### 加减运算

- 任何运算结果在(mod 2^8)以后只保留最低8位
- 补码: 让减法操作转变为加法操作, 节省硬件的成本
- 模-a的绝对值=a的补数(a为负数)
- 补码的作用: 使用补码可将减法操作转变为等价的加法, ALU中无需集成减法器. 执行加法操作时, 符号位一起参与运算

## 移位运算

### 原码的算术移位

原码的算数移位: 保持符号位不变, 仅对数值进行移位

> | 符  | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 | 实际值 | 操作     |
> | --- | --- | --- | --- | --- | --- | --- | --- | ------ | -------- |
>| 1   | 0   | 0   | 1   | 0   | 1   | 0   | 0   | -20D   |          |
>| 1   | 0   | 0   | 0   | 1   | 0   | 1   | 0   | -10D   | 右移一位 |
>| 1   | 0   | 0   | 0   | 0   | 1   | 0   | 1   | -5D    | 右移两位 |
>| 1   | 0   | 0   | 0   | 0   | 0   | 1   | 0 |-2D| 右移三位 |

右移: 高位补0, 低位舍弃. 若舍弃的位=0, 则相当于除以2; 若舍弃的位≠0, 则会丢失精度

> | 符  | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 | 实际值 | 操作     |
> | --- | --- | --- | --- | --- | --- | --- | --- | ------ | -------- |
> | 1   | 0   | 0   | 1   | 0   | 1   | 0   | 0   | -20D   |          |
> | 1   | 0   | 1   | 0   | 1   | 0   | 0   | 0   | -40D   | 左移一位 |
> | 1   | 1   | 0   | 1   | 0   | 0   | 0   | 0   | -80D    | 左移两位 |
> | 1   | 0   | 1   | 0   | 0   | 0   | 0   |0|-32D| 左移三位 |

### 反码的算术移位

反码的算数移位--正数的反码和原码相同, 因此对正数反码的移位运算也和原码相同<br>
<br> 右移: 高位补0, 低位舍弃
<br> 左移: 低位补0, 高位舍弃

反码的算数移位--负数的反码数值位与原码相反, 因此负数反码的移位运算规则如下<br>
<br> 右移: 高位补1, 低位舍弃
<br> 左移: 低位补1, 高位舍弃

### 补码的算数移位

补码的算数移位--正数的补码与原码相同, 因此对正数补码移位运算也和原码相同<br>
<br> 右移: 高位补0, 低位舍弃
<br> 左移: 低位补0, 高位舍弃

补码的算数移位--负数的补码=反码末位+1, 导致反码最右边几个连续的1都因进位而变为0, 直到碰到第一个0为止.
<br> 规律--负数补码中, 最右边的1及其右边同原码, 最右边的1的左边同反码<br>
<br> 负数移位的算数移位规则如下:
<br> 右移(同反码): 高位补1, 低位舍弃
<br> 左移(同原码): 低位补0, 高位舍弃

### 算数移位总结

|      | 码制           | 添补代码 |
| ---- | -------------- | -------- |
| 正数 | 原码\补码\反码 | 0        |
| 负数 | 原码           | 0        |
| 负数 | 补码           | 左移添0  |
| 负数 | 补码           | 右移添0  |
| 负数 | 反码           | 1        |

左移相当于*2, 右移相当于/2<br>
由于位数有限, 因此有时候无法用算数移位精确地等效乘除法

### 逻辑移位

逻辑移位可以看作是对无符号数的移位

移位规则:
<br> 逻辑左移时, 舍弃高位, 低位补0
<br> 逻辑右移时, 舍弃低位, 高位补0

### 循环移位

[带进位位的循环左移](https://blog.csdn.net/husion01/article/details/6541472)

## 加减运算和溢出运算

### 原码的加减运算

加法器直接对原码进行加法运算, 可能出错, 需要用减法器实现

原码的加法运算:
<br> 正+正 -> 绝对值做加法, 结果为正
<br> 负+负 -> 绝对值做加法, 结果为负
<br> 正+负 -> 绝对大的减绝对值小的, 符号同绝对值大的数
<br> 负+正 -> 绝对值大的减绝对值小的, 符号同绝对值大的数

原码的减法运算, "减数"符号取反, 转变为加法:
<br>  正-负 -> 正+正
<br> 负-正 -> 负+负
<br> 正-正 -> 正+负
<br> 负+正 -> 负-负

### 补码的加减运算

对于补码来说, 无论加法还是减法, 最后都会转变为加法, 由加法器实现运算, 符号位也参与运算

#### 负数补码转化为原码的方式

- 数值位取反+1
- 负数补码中, 最右边的1及其右边同原码. 最右边的1的左边同反码

#### 溢出判断

> 设机器的字长为8位(含1位符号位), A=15, B=-24
> <br> C=124, 求[A+C]补和[B-C]补
> <br> [A+C]补=0,000111+0,1111100=1,0001011 真值-117
> <br> [B-C]补=1,1101000+1,0000100=0,1101100 真值+108

- 只有"正数+正数"才会上溢--正+正=负
- 只有"负数+负数"才会下溢--负+负=正

##### 方法一 采用一位符号位

采用一位符号位, 设A的符号为As, B的符号为Bs, 运算结果的符号为Ss, 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+\overline{A_s}\overline{B_s}S_s$

若V=0, 表示无溢出
<br> 若V=1, 表示有溢出

溢出的两种情况: 
<br> As为1且Bs为1且Ss为0
<br> As为0且Bs为0且Ss为1

##### 方法二 采用一位符号位根据数据位的进位情况判断溢出

采用一位符号位, 根据数据位进位情况判断溢出

|      | 符号位的进位Cs | 最高数值位的进位C1 |
| ---- | -------------- | ------------------ |
| 上溢 | 0              | 1                  |
| 下溢 | 1              | 0                  |

即: Cs与C1不同时有溢出
<br> 处理不同的逻辑符号: 异或⊕
<br> 溢出逻辑判断表达式为V=Cs⊕C1
<br> 若V=0, 表示无溢出; V=1, 表示有溢出

##### 方法三 采用双符号位

正数符号为00, 负数符号为11

记两个符号位为Ss1,Ss2, 则V=Ss1⊕Ss2
<br> 若V=0, 表示无溢出; 若V=1, 表示有溢出

双符号位补码又称: 模4补码
单符号位补码又称: 模2补码

### 符号扩展

#### 正整数

> 01011010 -> 0000000001011010

#### 负整数

> ||转换前|转换后|
> |-|-|-|
> |原码|11011010|1000000001011010|
> |反码|10100101|1111111110100101|
> |补码|10100110|1111111110100110|

#### 正小数

> 0.1011010 -> 0.101101000000000

#### 负小数

> ||转换前|转换后|
> |-|-|-|
> |原码|1.1011010|1.101101000000000|
> |反码|1.0100101|1.010010111111111|
> |补码|1.0100110|1.010011000000000|

- 定点整数的符号扩展: 在原符号位和数值位中间添加新位, 正数都添0; 负数原码添0, 负数反, 补码添1
- 定点小数的符号扩展: 在原符号位和数值位后面添加新的位, 正数都添0; 负数原, 补码添0, 负数反码添1

## 原码乘法运算

### 原码一位乘法

符号单独处理: 符号位=Xs⊕ys, 数值位取绝对值进行乘法计算

实现方法: 先加法再移位, 重复n次

#### 手算实现方法

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/original%20code%20multiplication2.png)

- 乘数的符号位不参与运算, 可以忽略
- 原码一位乘可以只用单符号位
- 答题时最终结果最好写为原码机器数

原码一位乘法:
<br> 符号位通过异或确定; 数值部分通过被乘数和乘数绝对值的n轮加法, 移位完成. 根据当前乘数中参与运算的位确定(ACC)加什么. 若当前运算位=1, 则(ACC)+[|x|]原; 若当前运算位=0, 则(ACC)+0
<br> 每轮加法后ACC, MQ的内容统一逻辑右移

#### 机器实现方法

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/original%20code%20multiplication1.drawio.svg)

## 补码的乘法运算

### 补码一位乘法(Booth算法)

#### 原码一位乘法和补码一位乘法的区别

##### 原码一位乘法

- 原码中每次加法可能+0, +[|x|]原
  - MQ中最低位=1时, (ACC)+[|x|]原
  - MQ中最低位=0时, (ACC)+0
- 进行n轮加法, 移位
- 每次移位都是"逻辑右移"
- 符号位不参与运算

##### 补码一位乘法

- 每次加法可能+0, +[x]补, +[-x]补
  - 辅助位-MQ中最低位=1时, (ACC)+[x]补
  - 辅助位-MQ中最低位=0时, (ACC)+0
  - 辅助位-MQ中最低位=-1时, (ACC)+[-x]补
- 进行n轮加法, 移位, 最后再多来一次加法
- 每次移位都是"补码的算数右移"
- 符号位参与运算 
                                                       
#### 机器实现

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Two's%20complement%20multiplication1.drawio.svg)

#### 手算实现

- n轮加法, 算数右移, 加法规则如下:
  - 辅助位-MQ中最低位=1时, (ACC)+[x]补
  - 辅助位-MQ中最低位=0时, (ACC)+0
  - 辅助位-MQ中最低位=-1时, (ACC)+[-x]补
- 补码的算数右移:
  - 符号位不动, 数值位右移, 正数右移补0, 负数右移补1(符号位是啥就补啥)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Two's%20complement%20multiplication2.png)

## 原码的除法运算

### 不恢复余数法

#### 手算除法(二进制)

> 设机器字长为5位(含1位符号位, n=4), x=0.1011, y=0.1101, 求x/y
> <br> 规律: 忽略小数点, 每确定一位商, 进行一次减法, 得到4位余数, 在余数的末尾补0, 再确定下一位商, 确定5位商即可停止(机器字长为5位)

#### 机器实现

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/original%20code%20division1.drawio.svg)

##### 符号位

符号单独处理: 符号位=Xs⊕Ys

##### 数值位

- 计算机很傻, 会先默认上商1, 如果搞错了再改上商0, 并"恢复余数"
- ACC, MQ整体"逻辑左移". ACC高位丢弃, MQ低位补0

#### 手算实现

##### 恢复余数法

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/original%20code%20division2.png)

##### 加减交替法(不恢复余数法)

若余数a为负, 则可直接商0, 并让余数左移1位再加上|除数|

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/c71fa01b82dd65a30d7860a8c23668d9a673e90e/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/original%20code%20division4.png)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/original%20code%20division3.png)

##### 区别

- 恢复余数法: 当余数为负时商0, 并+|除数|, 再左移, 再-|除数|
- 加减交替法: 当余数为负时商0, 并左移, 再+|除数|

##### 注意

- 余数的正负性和商相同
- 若余数为负数, 则需要商0, 并+[|y|]补得到正确余数

## 补码的除法运算

### 加减交替法

补码除法:
- 符号位参与运算
- 被除数/余数, 除数采用双符号位

被除数和除数同号, 则被除数减去除数, 异号则被除数加上除数

余数和除数同号, 商1, 余数左移一位减去除数;
<br> 余数和除数异号, 商0, 余数左移一位加上除数;
<br> 重复n次

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Two's%20complement%20division1.png)

### 除法运算回顾

| 除法类型       | 符号位参与运算 | 加减次数 | 方向 | 次数 | 上商, 加减原则     | 说明                         |
| -------------- | -------------- | -------- | ---- | ---- | ------------------ | ---------------------------- |
| 原码加减交替法 | 否             | N+1或N+2 | 左   | N    | 余数的正负         | 若最终余数为负, 需要恢复负数 |
| 补码加减交替法 | 是             | N+1      | 左   | N    | 余数和除数是否同号 | 商末位恒置1                  |

## 强制类型转换

### 代码

```c
void main() {
    short x = -4321; // short类型占用2个字节, x: 1110 1111 0001 1111
    unsigned short y = (unsigned short)x; // 会将x的二进制数值完整地复制给y, y的值为1110 1111 0001 1111, 真值为61215. 无符号数与有符号数, 不改变数据内容, 改变解释方式
    int a = 165537, b = -34991; // int型占用4个字节, a:0x000286a1, b:0xffff7751
    short c = (short)a, d = (short)b; // short型占用2个字节, 长整数变短整数: 高位截断, 保留低位, c:0x86a1, 真值:-31071; d:0x7751, 真值:30545
    short x = -4321; // x:1110 1111 0001 1111 x:0xef1f
    int m = x; // m:1111 1111 1111 1111 1110 1111 0001 1111 m:0xffffef1f 真值:-4321
    unsigned short n = (unsigned short)x; // n:1110 1111 0001 1111 0xef1f 真值:61215
    unsigned int p = n; // p:0000 0000 0000 0000 1110 1111 0001 1111 0x0000ef1f 真值61215
}
```

## 数据的存储和排列

### 大小端模式

> 4字节int: 01 23 45 67H -> 19088743D -> 0000 0001 0010 0011 0100 0101 0110 0111B
> <br> 最高有效字节为01(MSB), 最低有效字节为67(LSB)

- 大端模式: 最高的有效字节存储在更低地址的部分, 最低有效字节存储在更高地址的部分(更适合人类阅读)
- 小端模式: 最低的有效字节存储在更低地址的部分, 最高有效字节存储在更高地址的部分(更适合机器存储)

### 边界对齐

现代计算机通常是按字节编址, 即每个字节对应1个地址
<br> 通常也支持按字, 按半字, 按字节寻址
<br> 假设存储字长为32位, 则1个字=32bit, 半字=16bit. 每次访存只能读/写1个字
<br> 字节始终是8位

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Data%20storage%20and%20arrangement.drawio.svg)

## 浮点数的表示和运算

### 从科学计数法理解浮点数

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Representation%20and%20operation%20of%20floating%20point%20numbers1.drawio.svg)

### 浮点数的表示

- 浮点数的真值: $N=r^E\times M$
- 阶码E: 常用补码或者移码表示的定点整数, 通常阶码的底是2
- 尾数M: 常用原码或者补码表示的定点小数, 数值部分的位数n反映浮点数的精度
- 尾数给出一个小数, 阶码指明了小数点要向前/向后移动几位
- 尾数的最高位是无效值, 会丧失精度

> 阶码, 尾数均用补码表示, 求a, b的真值
> <br> a=0,01; 1.1001
> <br> b=0,10; 0.10001
> <br> a: 阶码0,01对应真值+1; 尾数1.1001对应真值-0.0111=-(2^-2+2^-3+2^-4)
> <br> a的真值=2^1*(-0.0111)=-0.111, 相当于尾数表示的定点小数算数左移一位, 或小数点右移一位
> <br> b: 阶码0,10对应的真值位+2; 尾数0.01001对应的真值+0.01001=+(2^-2+2^-5)
> <br> b的真值=2^2*(+0.01001)=+1.001

### 浮点数尾数的规格化

规格化浮点数: 规定尾数的最高数值位必须是一个有效值

- 左规: 当浮点数运算结果为非规格化时要进行规格化处理
- 右规: 当浮点数运算的结果尾数出现溢出(双符号位为01或者10)时, 将尾数算数右移一位, 阶码加1

> a=010;00.1100, b=010;00.1000, 求a+b
> <br> a=2^2*00.1100, b=2^2*00.1000
> <br> a+b=2^2*00.1100+2^2*00.1000=2^2*(00.1100+00.1000)=2^2*01.0100=2^3*00.1010(发现溢出)

采用"双符号位", 当溢出发生的时候, 可以挽救. 更高的符号位是正确的符号位

### 规格化浮点数的特点

#### 用原码表示的尾数的规格化

- 正数为0.1XX...X的形式, 其最大值表示为0.11...1; 最小值表示为0.10...0
  - 尾数的表示范围为0.5≤M≤(1-2^(-n))
- 负数为1.1XX...X的形式, 其最大值表示为1.10...0, 最小值表示为1.11...1
  - 尾数的表示范围为-(1-2^(-n))≤M≤-0.5

#### 用补码表示的尾数进行格式化

- 正数为0.1XX...X的形式, 其最大值表示为0.11...1; 最小值表示为0.10...0
  - 尾数的表示范围为0.5≤M≤(1-2^(-n))
- 负数为1.0XX...X的形式, 其最大值表示为1.01...1; 最小值表示为1.00...0
  - 尾数的表示范围为-1≤M≤-(1/2+2^(-n))

> 若某浮点数的阶码, 尾数用补码表示, 共4+8位: 0,110; 1.1110100如何规格化?
> <br> 应该将数值部分左移3位, 并将阶码从+6变成+3. 
> <br> 补码算数左移, 低位补0; 补码算数右移, 高位补1.

## 浮点数标准 IEEE 754

### 移码

- 补码的基础上符号位取反. 注意: 移码只能用于表示整数
- 移码的定义: 移码=真值+偏置值; 偏置值一般取2^(n-1), 此时的移码=补码符号位取反. 偏置值也可以是其他的值, 比如说2^(n-1)-1

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/IEEE%207542.png)

### IEEE 754标准

| 类型       | 数符 | 阶码 | 尾数数值 | 总位数 | 十六进制 | 十进制 |
| ---------- | ---- | ---- | -------- | ------ | -------- | ------ |
| 短浮点数   | 1    | 8    | 23       | 32     | 7FH      | 127    |
| 长浮点数   | 1    | 11   | 52       | 64     | 3FFH     | 1023   |
| 临时浮点数 | 1    | 15   | 64       | 80     | 3FFFH    | 16383  |

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/IEEE%207541.drawio.svg)

- 阶码全1, 全0用作特殊用途, 故单精度浮点型数阶码真值的正常范围是-126~127
- 阶码的真值=移码-偏移量
- 规格化的短浮点数的真值为: (-1)^s*1.M*2^(E-127)
- 规格化的长浮点数的真值为: (-1)^s*1.M*2^(E-1023)

> 将十进制数-0.75转换为IEEE 754的单精度浮点数格式表示
> <br> (-0.75)10=-(0.11)2=(-1.1)2*2^(-1) 最后一步为规格化
> <br> 数符=1
> <br> 尾数部分=.1000000...(隐含的最高位1)
> <br> 阶码真值=-1
> <br> 单精度浮点型偏移量=127D
> <br> 移码=阶码真值+偏移量=-1+1111111=01111110(凑足8位)

> IEEE 754的单精度浮点数C0 A0 00 00H的值是多少
> <br> 数符=1 -> 是一个负数
> <br> 尾数部分=.0100... (隐含最高位1) -> 尾数真值=(1.01)2
> <br> 移码=10000001, 若看作无符号数=129D
> <br> 单精度浮点型偏移量=127D
> <br> 阶码真值=移码-偏移量=10000001-1111111=(00000010)2=(2)10
> <br> -> 浮点数真值=(-1.01)2*2^2=-1.25*2^2=-5.0

#### IEEE 754单精度浮点型能表示的最小绝对值, 最大绝对值是多少?

- 最小绝对值: 尾数全为0, 阶码真值最小-126, 对应的移码机器数为00000001, 此时整体的真值为(1.0)2*2^(-126)
- 最大绝对值: 尾数权为1, 阶码真值最大127, 对应移码机器数11111110, 此时整体的真值为(1.111...11)2*2^127

| 格式   | 格式化的最小绝对值                 | 格式化的最大绝对值                                           |
| ------ | ---------------------------------- | ------------------------------------------------------------ |
| 单精度 | E=1, M=0: 1.0*2^(1-127)=2^(-126)   | E=-254, M=.11...1: 1.11...1*2^(254-127)=2^127*(2-2^(-23))    |
| 双精度 | E=1, M=0: 1.0*2^(1-1023)=2^(-1022) | E=2046, M=.11...1: 1.11...1*2^(2046-1023)=2^1023*(2-2^(-52)) |

#### 表示绝对值更小的浮点数

- 阶码全1或者全0用作特殊用途
- 当阶码E不全为0, 尾数M不全为0的时候, 也就是只有1≤E≤254时, 真值=(-1)^s*1.M*2^(E-127)(隐含的最高位变为1)
- 当阶码E全为0, 尾数M不全为0的时候, 表示非规格化小数±(0.xx...x)2*2^(-126)(隐含的最高位变为0, 阶码真值固定视为-126)
- 当阶码E全为0, 尾数M全为0的时候, 表示真值±0
- 当阶码E全为1, 尾数M全为0的时候, 表示无穷大±∞(发生上溢或者下溢的时候会出现这种情况
- 当阶码E全为1, 尾数M不全为0的时候, 表示非数值"NaN"(Not a Number, 0/0, ∞-∞等非法运算的结果就是NaN)

## 浮点数的运算

### 浮点数的加减运算

> 9.85211*10^12+9.96007*10^10

#### 对阶

> 9.85211*10^12+0.0996007*10^12

为何小阶向大阶对齐?
<br> 因为在计算机内部, 尾数是定点小数

#### 尾数相减

> 9.9517107*10^12

#### 规格化

> 如果尾数加减出现类似0.定点9517*10^12时, 需要"左规"; 如果尾数加减出现类似99.517107*10^12时, 需要"右规"

#### 舍入

> 若规定只能保留6位有效尾数, 则9.9517107*10^12 -> 9.95171*10^12 (多余的直接砍掉); 或者, 9.9517107*10^12 -> 9.95172*10^12(若砍掉部分非0, 则入1); 或者, 也可以采用四舍五入的原则, 当舍弃位≥5时, 高位入1

#### 判断溢出

> 若规定阶码不能超过两位, 则运算后阶码超出范围, 则溢出. 如:9.85211*10^99+9d.96007*10^99=19.81218*10^99, 规格化并用四舍五入的原则保留6位尾数, 得1.98122*10^100. 阶码超过两位, 发生溢出(注: 尾数溢出未必导致整体溢出, 也许可以通过③④两步来拯救)

### 加减运算示例

> 已知十进制数X=-5/256, Y=59/1024, 按机器补码浮点运算规则计算X-Y, 结果用二进制表示, 浮点数格式如下: 阶符取2位, 阶码取3位, 数符取2位, 尾数取9位
> <br> 用补码表示阶码和尾数: 5D=101B, 1/256=2^(-8)->X=-101*2^(-8)=-0.101*2^(-5)=-0.101*2^(-101); 59D=111011B, 1/1024=2^(-10)->Y=+111011*2^(-10)=+0.111011*2^(-4)=+0.111011*2^(-100)
> <br> X的阶码双符号位补码: 11011; 尾数双符号位补码并扩展: 11.011000000; Y的阶码和尾数自己算. 最终得到X: 11011,11.011000000; Y: 11100,00.111011000
> 
> 1. 对阶: 使两个数的阶码相等, 小阶向大阶看齐, 尾数每右移一位, 阶码+1. 求阶差: [∆E]补=11011+00100=11111, 知∆E=-1; 对阶: X: 11011,11.011000000 -> 11100,11.101100000
> 2. 尾数加减: -Y: 11100,11.000101000; X-Y=: 11100,10.110001000, 由双符号位得出发生溢出, 但是可以通过规格化拯救溢出
> 3. 规格化: X-Y: 11100, 10.110001000 -> 11101, 11.011000100
> 4. 舍入: 无舍入
> 5. 判断溢出: 常阶码, 无溢出, 结果真值为2^(-3)*(-0.1001111)2

### 浮点数的加减运算-舍入

#### "0"舍"1"入法

类似于十进制数运算中的"四舍五入"法, 即在尾数右移的时候, 被移去的最高位数值为0, 则舍去; 被移去的最高位数值为1, 则在尾数的末位加1. 这样做可能会使尾数又溢出, 此时需要再做一次右规

#### 恒置"1"法

尾数右移的时候, 不论丢掉的最高数值位是"1"还是"0", 都使右移后的尾数末位恒置"1". 这种方法同样有使尾数变大和变小的两种可能

### 强制类型转换

| 类型      | 16位机器 | 32位机器 | 64位机器 |
| --------- | -------- | -------- | -------- |
| char      | 8        | 8        | 8        |
| short     | 16       | 16       | 16       |
| int       | 16       | 32       | 32       |
| long      | 32       | 32       | 64       |
| long long | 64       | 64       | 64       |
| float     | 16       | 32       | 32       |
| double    | 64       | 64       | 64       |

- char -> int -> long -> double: 如果long是32bit的话, 则long转换为double为无损转化. 如果long是64bit的话, 则long转化为double为有损转换, 因为double的有效数值位只有53位
- float -> double: 不会损失精度

#### 32位int和float

- int: 表示整数, 1位符号位+31位数值位, 范围-2^(31)~2^(31)-1, 有效数字32位
- float: 表示整数及小数, 范围±[2^(-126)~2^(127)*(2-2^(-23))], 1位符号位8个阶码23个尾数, 有效数字23+1=24位

1. int -> float: 可能损失精度
2. float -> int: 可能溢出及损失精度(小数转化为小数的时候)

## 电路基本原理&加法器设计

### 算数逻辑单元(ALU)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Circuit%20Fundamentals%20&%20Adder%20Design1.drawio.svg)

### 最基本的逻辑运算

- $A(C+D)=AC+AD$ --- 分配律
- $ABC=A(BC)$ --- 结合律
- $A+B+C=A+(B+C)$ --- 结合律

#### "与"

$Y=A·B$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

#### "或"

$Y=A+B$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 1   |

#### "非"

$Y=\overline{A}$

| A   | Y   |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

### 复合逻辑运算

- $\overline{A+B}=\overline{A}\cdot \overline{B}$
- $\overline{A\cdot B}=\overline{A}+\overline{B}$ 

#### "与非"

$Y=\overline{A·B}$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |

#### "或非"

$Y=\overline{A+B}$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 0   |

#### "异或"

$Y=A⊕B=\overline{A}\cdot B+A\cdot \overline{B}$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |

#### "同或"

$Y=A⊙B$

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

### 一位全加器(FA, full adder)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Circuit%20Fundamentals%20&%20Adder%20Design3.drawio.svg)

#### 输入

$A_i, B_i, C_{i-1}$

#### 输出

- $S_i=A_i⊕B_i⊕C_{i-1}$: 输入有奇数个1时为1(异或)
- $C_i=A_iB_i+(A_i⊕B_i)C_{i-1}$: 输入中至少2个1(两个为都是1或者两个本位中有一个是1, 且来自低位的进位是1)

#### 电路设计

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Circuit%20Fundamentals%20&%20Adder%20Design2.png)

### 串行加法器

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Circuit%20Fundamentals%20&%20Adder%20Design4.drawio.svg)

- 只有一个全加器, 数据逐位串行送入加法器中进行运算. 进位触发器用来寄存进位信号, 以便参与下一次运算.
- 如果操作数长n位, 加法就要分为n次进行, 每次产生一位和, 并且串行逐位送回寄存器

### 并行加法器

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Circuit%20Fundamentals%20&%20Adder%20Design5.drawio.svg)

- 把n个全加器串接起来, 就可进行两个n位数的相加
- 串行进位又称为行波进位, 每一级进位直接依赖于前一级的进位, 即进位信号是逐级形成的

## 加法器&ALU的改进

### 如何更快地产生进位?

$C_i=A_iB_i+(A_i⊕B_i)C_{i-1}$
<br> $C_i=A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1}C_{i-2}))$
<br> $C_i=A_iB_i+(A_i⊕B_i)(A_{i-1}B_{i-1}+(A_{i-1}⊕B_{i-1}(A_{i-2}B_{i-2}+(A_{i-2}⊕B_{i-2})C_{i-3}))$
<br> ...
终有一天可以展开到$C_0$

第i位向更高位的进位可根据被加数, 加数的第1~i位, 再结合C0确定

### 并行加法器的优化

记$G_i=A_iB_i, P_i=A_i⊕B_i$, 可以将上述的式子化简, 得到:
<br> $C_1=G_1+P_1C_0$
<br> $C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0$
<br> $C_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$
<br> $C_4=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0$
<br> ...

并行进位的并行加法器: 各级进位信号同时形成, 又称为先行进位, 同时进位. 但是, 继续套娃会导致电路越来越复杂, 故一般只支持四位进位并行处理, 也就是4位CLA加法器

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Adder&ALU%20Improvements1.drawio.svg)

由4个FA和一些新的线路, 运算逻辑组成

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Adder&ALU%20Improvements2.png)

#### 单级先行进位方式(组内并行, 组间串行)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Adder&ALU%20Improvements3.drawio.svg)

组内进位信号: 
<br> $C_1=G_1+P_1C_0$
<br> $C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0$
<br> $C_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$
<br> $C_4=G_4+P_4C_3=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1+P_4P_3P_2P_1C_0$

记: $G_1^*=G_4+P_4G_3+P_4P_3G_2+P_4P_3P_2G_1; P_1^*=P_4P_3P_2P_1$

$G_1^*$称为组进位产生函数, $P_i^*$称为组进位传递函数. 根据本组的4*2个输入位即可确定本组的$G_1^*$和$P_i^*$

组间传递信号:
<br> $C_4=G_1^*+P_1^*C_0$
<br> $C_8=G_2^*+P_2^*C_4=G_2^*+P_2^*G_1^*+P_2^*P_1^*C_0$
<br> $C_{12}=G_3^*+P_3^*C_8=G_3^*+P_3^*G_2^*+P_3^*P_2^*G_1^*+P_3^*P_2^*P_1^*C_0$
<br> $C_{16}=G_4^*+P_4^*C_{12}=G_4^*+P_4^*G_3^*+P_4^*P_3^*G_2^*+P_4^*P_3^*P_2^*G_1^*+P_4^*P_3^*P_2^*P_1^*C_0$

#### 多级先行进位方式(组内并行, 组间并行)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Adder&ALU%20Improvements4.drawio.svg)

### ALU芯片的优化

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/Adder&ALU%20Improvements5.png)

# 第三章 存储系统

## 存储系统基本概念

### 存储器的层次化结构

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/Basic%20Concepts%20of%20Storage%20Systems1.drawio.svg)


辅存中的数据要调入主存后才被CPU访问

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/b618de65fede82c3c4e3e6bb26c0c5966994e9b3/Computer-Organization%20WD/Storage%20System/SVG/Basic%20Concepts%20of%20Storage%20Systems2.drawio.svg)

有的教材把安装在电脑内部的磁盘称为"辅存", 把U盘, 光盘等称为"外存". 也有的教材把磁盘, U盘, 光盘等统称为"辅存"或者"外存"

- 主存-辅存: 实现虚拟操作系统, 解决了主存容量不够的问题
- Cache-主存: 解决了主存与CPU速度不匹配的问题

### 存储器的分类

#### 按照层次

- 高速缓存(Cache)
- 主存储器(主存, 内存)
- 辅助存储器(辅存, 外存)

#### 存储介质

- 半导体存储器(主存, Cache)
- 磁表面存储器(磁盘, 磁带)
- 光存储器(光盘, DVD)

#### 存取方式

- 随机存取存储器(Random Access Memory, RAM): 读写任何一个存储单元所需的时间都相同, 与存储单元所在的物理位置无关
- 顺序存取存储器(Sequential Access Memory, SAM): 读写一个存储单元所需的时间取决于存储单元所在的物理位置
- 直接存取存储器(Direct Access Memory, DAM): 既有随机存取特性, 也有顺序存储的特性. 先直接选取信息所在的区域, 然后按照顺序方式存取
- 相联存储器(Associative Memory), 即可以按内容访问的存储器(Content Addressed Memory, CAM), 可以按照内容检索到存储位置进行读写, "快表"就是一种相联存储器

串行访问存储器: 读写某个存储单元所需的时间和存储单元的物理位置有关, 上述SAM和DAM就是串行访问存储器

RAM, SAM和DAM是按照地址来访问, CAM是按照内容来访问

#### 信息的可更改性

- 读写存储器(Read/Write Memory) -- 既可读, 也可写(如: 磁盘, 内存, Cache)
- 只读存储器(Read Only Memory) -- 只能读, 不能写(如: 实体音乐专辑通常采用的CD-ROM, 实体电影中采用的蓝光光碟, BIOS通常写在ROM中)

#### 信息的可保存性

- 断电后, 存储信息消失的存储器 -- 易失性存储器(主存, Cache)
- 断电后, 存储信息依然保持的存储器 -- 非易失性存储器(磁盘, 光盘)

- 信息读出后, 原存储信息被破坏 -- 破坏性读出(如DRAM芯片, 读出数据后要进行重写)
- 信息读出后, 原存储信息不会被破坏 -- 非破坏性读出(如SRAM芯片, 磁盘, 光盘)

### 存储器的性能指标

- 存储容量: 存储字数*字长
- 单位成本: 每位价格=总成本/总容量
- 存储速度: 数据传输率=数据的宽度/存储周期

1. 存储时间(Ta): 存取时间指的是从启动一次存储器操作到完成该操作所经历的时间, 分为读出时间和写入时间
2. 存取周期(Tm): 存取周期又称为读写周期或者访问周期, 它是指存储器进行一次完整的读写操作所需要的全部时间, 即连续两次独立地访问存储器操作(读或写操作)之间所需要的最小时间间隔

主存带宽(Bm): 主存带宽又称为数据传输率, 表示每秒从主存进出信息的最大数量, 单位为字/秒, 字节/秒或者位/秒

## 主存储器的基本组成

### 基本的半导体元件及原理

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/The%20basic%20components%20of%20main%20memory1.drawio.svg)

一个内存颗粒上的金属引脚:
1. 地址线
2. 数据线
3. 读写控制线(1个或2个)
4. 片选线(1个)
5. 供电引脚
6. 接地引脚

> 常见的描述: 
> <br> 8K*8位, 即2^13*8bit
> <br> 8K*1位, 即2^13*1bit
> <br> 64K*16位, 即2^16*16bit

### 寻址

总容量为1KB(字长4B):

- 按照字节寻址: 1K个单元, 每个单元1B
- 按字寻址: 256个单元, 每个单元4B
- 按半字寻址: 512个单元, 每个单元2B
- 按双字寻址: 128个单元, 每个单元8B

## SRAM&DRAM

### 栅极电容 V.S. 双稳态触发器

| 类型特点           | SRAM(静态RAM) | DRAM(动态RAM)            |
| ------------------ | ------------- | ------------------------ |
| 存储信息           | 触发器        | 电容                     |
| 破坏性读出         | 非            | 是                       |
| 读出后需要重写?    | 不用          | 需要                     |
| 运行速度           | 快            | 慢                       |
| 集成度             | 低            | 高                       |
| 发热量             | 大            | 小                       |
| 存储成本           | 高            | 低                       |
| 易失/非易失存储器? | 易失          | 易失                     |
| 需要刷新?          | 不需要        | 需要(分散, 集中, 异步)   |
| 送行列地址         | 同时送        | 分两次送(地址线复用技术) |
| 用途               | 常用作Cache   | 常用作主存               |

#### 栅极电容(DRAM存储元)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/SRAM&DRAM1.png)

- 读出1: MOS管接通, 电容放电, 数据线上产生电流
- 读出0: MOS管接通后, 数据线上无电流

电容放电信息被破坏, 是破坏性读出, 读出后应有重写操作, 也成为"再生", 读写速度更慢

每个存储单元制造成本更低, 集成度更高, 功耗低

#### 双稳态触发器(SRAM存储元)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/SRAM&DRAM2.png)

双稳态:
<br> 1: A高B低
<br> 0: A低B高

读出数据, 触发器状态保持稳定, 是非破坏性读出, 无需重写, 读写速度更快

每个存储单元制造成本更高, 集成度低, 功耗大

### DRAM的刷新

1. 多久刷新一次? 刷新周期: 一般为2ms
2. 每次刷新多少存储单元? 以行为单位, 每次刷新一行存储单元
3. 如何刷新? 有硬件的支持, 读出一行的信息后重新写入, 占用1个读/写周期
4. 在什么时刻刷新? 

#### 为什么要用行列地址?

> 地址为00000000, 前半部分(0000)作为行地址送给行地址译码器, 后半部分(0000)作为列地址送给列地址译码器. 如果采用非矩阵模型, 则需要2^8=256根选通线, 如果采用矩阵模型, 则需要2^4+2^4根选通线(排列成16*16的矩阵)

#### 在什么时刻刷新?

> 假设DRAM内部结构排列成128*128的形式, 读/写周期0.5us, 2ms共2ms/0.5us=4000个周期

##### 分散刷新

> 每次读写完都刷新一行, 系统的存取周期变为1us, 前0.5us时间属于正常读写, 后0.5us时间属于刷新某行

##### 集中刷新

> 2ms内集中安排时间全部刷新, 系统的存取周期还是0.5us, 有一段使时间专门用于刷新, 无法访问存储器, 称为访存"死区"
> <br> 3872个周期(1936us)用于读写, 128个周期(64us)用于刷新

##### 异步刷新

> 2ms内每行刷新1次即可, 2ms内需要产生128次的刷新请求, 每隔2ms/128=15.6us一次, 每15.6us内有0.5us的"死时间"

### DRAM的地址线复用技术

同时传送行地址和列地址会导致地址线很多(n条), 故采用地址线复用技术, 采用n/2条地址线, 先将行地址送入行地址缓冲器, 再将列地址送入列地址缓冲器, 最后分别送到行地址译码器和列地址译码器. 会导致地址线, 地址线的引脚减半

## SRAM&DRAM

### 栅极电容 V.S. 双稳态触发器

| 类型特点           | SRAM(静态RAM) | DRAM(动态RAM)            |
| ------------------ | ------------- | ------------------------ |
| 存储信息           | 触发器        | 电容                     |
| 破坏性读出         | 非            | 是                       |
| 读出后需要重写?    | 不用          | 需要                     |
| 运行速度           | 快            | 慢                       |
| 集成度             | 低            | 高                       |
| 发热量             | 大            | 小                       |
| 存储成本           | 高            | 低                       |
| 易失/非易失存储器? | 易失          | 易失                     |
| 需要刷新?          | 不需要        | 需要(分散, 集中, 异步)   |
| 送行列地址         | 同时送        | 分两次送(地址线复用技术) |
| 用途               | 常用作Cache   | 常用作主存               |

#### 栅极电容(DRAM存储元)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/SRAM&DRAM1.png)

- 读出1: MOS管接通, 电容放电, 数据线上产生电流
- 读出0: MOS管接通后, 数据线上无电流

电容放电信息被破坏, 是破坏性读出, 读出后应有重写操作, 也成为"再生", 读写速度更慢

每个存储单元制造成本更低, 集成度更高, 功耗低

#### 双稳态触发器(SRAM存储元)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/SRAM&DRAM2.png)

双稳态:
<br> 1: A高B低
<br> 0: A低B高

读出数据, 触发器状态保持稳定, 是非破坏性读出, 无需重写, 读写速度更快

每个存储单元制造成本更高, 集成度低, 功耗大

### DRAM的刷新

1. 多久刷新一次? 刷新周期: 一般为2ms
2. 每次刷新多少存储单元? 以行为单位, 每次刷新一行存储单元
3. 如何刷新? 有硬件的支持, 读出一行的信息后重新写入, 占用1个读/写周期
4. 在什么时刻刷新? 

#### 为什么要用行列地址?

> 地址为00000000, 前半部分(0000)作为行地址送给行地址译码器, 后半部分(0000)作为列地址送给列地址译码器. 如果采用非矩阵模型, 则需要2^8=256根选通线, 如果采用矩阵模型, 则需要2^4+2^4根选通线(排列成16*16的矩阵)

#### 在什么时刻刷新?

> 假设DRAM内部结构排列成128*128的形式, 读/写周期0.5us, 2ms共2ms/0.5us=4000个周期

##### 分散刷新

> 每次读写完都刷新一行, 系统的存取周期变为1us, 前0.5us时间属于正常读写, 后0.5us时间属于刷新某行

##### 集中刷新

> 2ms内集中安排时间全部刷新, 系统的存取周期还是0.5us, 有一段使时间专门用于刷新, 无法访问存储器, 称为访存"死区"
> <br> 3872个周期(1936us)用于读写, 128个周期(64us)用于刷新

##### 异步刷新

> 2ms内每行刷新1次即可, 2ms内需要产生128次的刷新请求, 每隔2ms/128=15.6us一次, 每15.6us内有0.5us的"死时间"

### DRAM的地址线复用技术

同时传送行地址和列地址会导致地址线很多(n条), 故采用地址线复用技术, 采用n/2条地址线, 先将行地址送入行地址缓冲器, 再将列地址送入列地址缓冲器, 最后分别送到行地址译码器和列地址译码器. 会导致地址线, 地址线的引脚减半

## read only memory ROM

### 了解各种ROM

#### MROM(Mask Read-Only Memory)

掩模式只读存储器: 厂家按照客户需求, 在芯片生产过程中直接写入信息, 之后任何人不得重写(只能读出), 可靠性高, 灵活性差, 生产周期长, 知识和批量定制

#### PROM(Programmable Read-Only Memory)

可编程只读存储器: 用户可用专门的额PROM写入器写入信息, 写一次之后就不可更改

#### EPROM(Erasable Programmable Read-Only Memory)

允许用户写入信息, 之后采用某种方法擦除数据, 可进行多次重写

- UVEPROM(ultraviolet rays): 用紫外线照射8~20分钟, 擦除所有的信息
- EEPROM(第一个E是Electrically): 可用"电擦除"的方式, 擦除特定的字

#### Flash Memory

闪速存储器: 在EEPROM的基础上发展而来, 断电后也能保存信息, 且可进行多次快速的擦除和重写. 由于闪存需要先擦除再写入, 故闪存的"写"的速度要比"读"的速度慢. (U盘, SD卡就是闪存)

#### SSD(Solid State Drives)

固态硬盘: 由控制单元+存储单元(Flash芯片)组成, 与闪速存储器的核心区别在于控制单元不一样, 但存储介质都类似, 可进行多次快速地擦除和重写你, SSD速度快, 功耗低, 价格高. 目前个人电脑常常使用SSD取代传统的机械硬盘(手机辅存也使用Flash芯片, 但是相比SSD使用的芯片集成度高, 功耗低, 价格贵)

### 计算机内的重要ROM

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/read%20only%20memory%20ROM1.drawio.svg)

主板上的BIOS芯片就是ROM, 通常我们所说的内存条就是"主存", 但事实上, 主板上的ROM芯片也是"主存"的一部分, 逻辑上, 主存由RAM+ROM组成, 且两者常统一编址

## 主存储器与CPU的连接

### 增加主存的字长-位扩展

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Connection%20between%20main%20memory%20and%20CPU1.png)

### 增加主存的存储字数-字扩展

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Connection%20between%20main%20memory%20and%20CPU2.png)

### 增加主存的存储字数-字位扩展

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Connection%20between%20main%20memory%20and%20CPU3.png)

## 双口RAM&多模块存储器

### 存取周期

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/Dual-port%20ram%20&%20multi-module%20memory1.drawio.svg)

存取周期: 可以连续读/写的最短时间间隔

DRAM芯片的恢复时间比较长, 有可能是存取时间的几倍(SRAM的恢复时间较短), 如DRAM的存取时间为r, 存取周期为T, 则T=4r 

产生的问题: 
1. 多核CPU要访问内存, 怎么办? 
2. CPU的读写速度比主存快很多, 主存恢复时间太长怎么办?

### 双端口RAM

需要有两组完全独立的数据线, 地址线, 控制线. CPU, RAM中也要有更加复杂的控制电路

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Dual-port%20ram%20&%20multi-module%20memory2.png)

两个端口对同一主存操作有以下四种情况:
1. 两个端口同时对不同的地址单元存取数据(可以实现)
2. 两个端口同时对同一地址单元读出数据(可以实现)
3. 两个端口同时对同一地址单元写入数据(写入错误)
4. 两个端口同时对同一地址单元, 一个写入数据, 另一个读出数据(读出错误)

解决方法: 置"忙"信号为0, 由判断逻辑决定暂时关闭一个端口(即被延时), 未被关闭的端口正常访问, 被关闭的端口延长一个很短的时间段后再访问

作用: 优化多核CPU访问一根内存条的速度

### 多体并行存储器

> 每个存储体存取周期为T, 存取时间为r, 假设T=4r
> <br> 连续访问: 00000, 00001, 00010, 00011, 00100

为什么要考虑"连续访问"的情况?
<br> 因为在实际应用中, 有很多数据是连续的存储在主存中的, 比如说数组, 程序的指令都是连续的存储在主存中的

#### 高位交叉编址

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Dual-port%20ram%20&%20multi-module%20memory3.png)

> 连续取n个存储字
> <br> 耗时nT, 耗时5T

#### 低位交叉编址

宏观上读写一个字的时间接近r

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Dual-port%20ram%20&%20multi-module%20memory4.png)

> 耗时T+4r=2T
> <br> 连续存n个存储字
> <br> 耗时T+(n-1)r

### 应该取第几个"体"?

采用"流水线"的方式并行存取(宏观上并行, 微观上串行). 宏观上, 一个存储周期内, m体交叉存储器可以提供的数据量为单个模块的m倍

存取周期为T, 存取时间(总线传输周期)为r, 为了使流水线不间断, 应保证模块的数量m≥T/r:
1. 如果m<T/r, 则会导致CPU需要等待
2. 如果m>T/r, 则会导致芯片闲置

### 多模块存储器

#### 多体并行存储器

每个模块都有相同的容量和存取速度
<br> 各模块都有独立的读写控制电路, 地址寄存器和数据寄存器. 它们既能并行工作, 又能交叉工作.

#### 单体多字存储器

每个存储单元存储m个字
<br> 总线宽度也为m个字
<br> 一次并行读出m个字
<br> 每次只能同时取m个字, 不能单独取其中某个字, 指令和数据在主存中必须是连续存放的

### 内存条

单纯的扩容: 实现高位交叉的多体存储器
双通道: 实现低位交叉的多体存储器

买内存条时, 可挑选相同主频(主频反映的是存取周期, 如果主频不一样, 可能会导致高主频的内存降频), 相同容量(高容量的部分会按单通道处理)的两根来组成双通道

## Cache的基本概念和原理

### 存储系统存在的问题

1. 经过多模块存储器优化后, 存储器的速度和CPU的速度差距依然很大
2. 可以采用更加高速的存储单元设计, 但是会导致存储器的价格上升, 容量下降
3. 故基于程序的局部性原理, 可以增加一个Cache层, 改善"Cache-主存"的层次

### Cache的工作原理

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/Basic%20Concepts%20and%20Principles%20of%20Cache1.drawio.svg)

实际上, Cache被集成在CPU内部, Cache用SRAM实现, 速度快, 成本高

### 局部性原理

- 空间局部性: 在最近的未来要用到的信息(指令和数据), 很可能与现在正在使用的信息在存储空间上是邻近的(比如说数组元素, 顺序执行的指令代码)
- 时间局部性: 在最近的未来要用到的信息, 很可能是现在正在使用的信息(循环结构的指令代码)

基于局部性原理, 不难想到, 可以把CPU当前访问地址"周围"的部分数据存放到Cache中. 程序B按照"列优先"访问二维数组, 空间局部性更差

### 性能分析

设tc为访问一次Cache所需要的时间, tm为访问一次主存所需要的时间

- 命中率H: CPU欲访问的信息已在Cache中的比率
- 缺失(未命中)率: M=1-H

Cache-主存系统的平均访问时间t为: t=Htc+(1-H)(tc+tm)(先访问Cache, 若Cache未命中再访问主存); 或者t=Htc+(1-H)tm(同时访问Cache和主存, 若Cache命中则立即停止访问主存)

> 假设Cache的速度是主存的5倍, 且Cache的命中率为95%, 则采用Cache后, 存储器性能提高多少(设Cache和主存同时被访问, 若Cache命中则中断访问主存)?
> <br> 设Cache的存取周期为t, 则主存的存取周期为5t
> <br> 若Cache和主存同时访问, 命中时访问时间为t, 未命中时访问时间为5t, 平均访问时间为0.95*t+0.05*5t=1.2t, 故性能为原来的5t/1.2t≈4.17倍
> <br> 若先访问Cache再访问主存, 命中时访问时间为t, 未命中时访问时间为t+5t, 平均访问时间为0.95*t+0.05*6t=1.25t, 故性能为原来的5t/1.25t=4倍

### 有待解决的问题

#### 问题1

基于局部性原理, 不难想到, 可以把CPU目前访问的地址"周围"的部分数据放到Cache中. 如何界定"周围"?

将主存的存储空间"分块", 如:每1KB为一块, 主存和Cache之间以"块"为单位进行数据交换

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/Basic%20Concepts%20and%20Principles%20of%20Cache2.drawio.svg)

主存的地址共22位: 块号12位, 块内地址10位, 4M=2^22, 1K=2^10, 整个主存被分为2^12=4096块

#### 问题2

如何区分Cache和主存的数据块对应关系? - Cache和主存的映射方式

#### 问题3

Cache很小, 主存很大, 如果Cache满了怎么办? - 替换算法

#### 问题4

CPU修改了Cache中的数据副本, 如何确保主存中数据母本的一致性? - Cache写策略

## Cache和主存的映射方式

### 全相联映射(随意放)

> 假设某个计算机的主存地址空间大小为256MB, 按照字节编址, 其数据Cache有8个Cache行, 行长为64B
> <br> Cache的总大小为512B, 256M=2^28, 主存的地址共28位, 2^28/2^6=2^22, 主存块号共22位, 块内地址共6位
> CPU访问主存地址1...1101 001110:
> 1. 主存地址的前22位, 对比Cache中所有块的标记
> 2. 若标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元
> 3. 若未命中或有效位=0, 则正常访问主存

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Cache%20and%20main%20memory%20mapping1.png)

### 直接映射(只能放固定位置)

主存块在Cache中的位置=主存块号%Cache总块数, 缺点是其他地方有空闲Cache块, 但是8号主存块不能使用

主存块号%(2^3), 相当于留下最后三位二进制数(若Cache总块数=2^n, 则主存块号末位n位直接反映它在Cache中的位置), 将主存块号的其余作为标记即可

> CPU访问主存地址0...01000 001110: 
> 1. 根据主存块号的后3位确定Cache行
> 2. 若主存块号的前19位与Cache标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元
> 3. 若未命中或者有效位=0, 则正常访问主存

### 组相联映射(可放到特定分组)

所属分组=主存块号%分组数

主存块号%2^2, 相当于留下最后两位

> CPU访问主存地址1...1101001110: 
> 1. 根据主存块号的后2位确定所属分组号
> 2. 若主存块号的前20位与分组内的某个标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元
> 3. 若未命中或者有效位=0, 则正常访问

## Cache替换算法

### 随机算法(RAND)

随机算法(RAND, Random) -- 若Cache已满, 则随机选择一块替换

> 设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}
> |访问主存块|1|2|3|4|1|2|5|1|2|3|4|5|
> |-|-|-|-|-|-|-|-|-|-|-|-|-|
> |Cache #0|1|1|1|1|1|1|1|1|1|1|4|4|
> |Cache #1||2|2|2|2|2|2|2|2|2|2|2|
> |Cache #2|||3|3|3|3|5|5|5|5|5|5|
> |Cache #3||||4|4|4|4|4|4|3|3|3|
> |Cache命中?|否|否|否|否|是|是|否|是|是|否|否|是|
> |Cache替换?|否|否|否|否|否|否|是|否|否|是|是|否|

随机算法 -- 实现简单, 但完全没考虑局部性原理, 命中率低, 实际效果很不稳定

### 先进先出算法(FIFO)

先进先出算法(FIFO, First In First Out) -- 若Cache已满, 则替换最先被调入Cache的块

> 设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}
> |访问主存块|1|2|3|4|1|2|5|1|2|3|4|5|
> |-|-|-|-|-|-|-|-|-|-|-|-|-|
> |Cache #0|1|1|1|1|1|1|5|5|5|5|4|4|
> |Cache #1||2|2|2|2|2|2|1|1|1|1|5|
> |Cache #2|||3|3|3|3|3|3|2|2|2|2|
> |Cache #3||||4|4|4|4|4|4|3|3|3|
> |Cache命中?|否|否|否|否|是|是|否|否|否|否|否|否|
> |Cache替换?|否|否|否|否|否|否|是|是|是|是|是|是|

先进先出算法 -- 实现简单, 最开始按照#0#1#2#3放入Cache, 之后轮流替换#0#1#2#3, FIFO依然没有考虑局部性原理, 最先被调入Cache的块也有可能是被频繁访问的

抖动现象: 频繁的换入换出现象(刚被替换的块很快又被调入)

### 近期最少使用算法(LRU)

近期最少使用算法(LRU, Least Recently Used) -- 为每一个Cache块设置一个"计数器", 用于记录每个Cache块已经有多久没有被访问了. 当Cache满后替换"计数器"最大的

> 设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}
> |访问主存块|1|2|3|4|1|2|5|1|2|3|4|5|
> |-|-|-|-|-|-|-|-|-|-|-|-|-|
> |Cache #0|1|1|1|1|1|1|1|1|1|1|1|5|
> |Cache #1||2|2|2|2|2|2|2|2|2|2|2|
> |Cache #2|||3|3|3|3|5|5|5|5|4|4|
> |Cache #3||||4|4|4|4|4|4|3|3|3|
> |Cache命中?|否|否|否|否|是|是|否|是|是|否|否|否|
> |Cache替换?|否|否|否|否|否|否|是|否|否|是|是|是|

1. 命中时, 所命中的行的计数器清零, 比其低的计数器+1, 其余不变;
2. 未命中且还有空闲行时, 新装入的行的计数器置0, 其余非空闲行全加1;
3. 未命中且无空闲行时, 计数值最大的行的信息块被淘汰, 新装行的块的计数器置0, 其余全加1

Cache块的总数=2^n, 则计数器只需要n位. 且Cache装满后所有计数器的值一定不重复

LRU算法 -- 基于"局部性原理", 近期被访问过的主存块, 在不久的将来也很有可能被再次访问, 因此淘汰最久没访问过的块是合理的. LRU算法的实际效果优秀, Cache命中率高. 若被频繁访问的主存块数量>Cache行的数量, 则有可能发生抖动, 如:{1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2...}

### 最不经常使用算法(LFU)

最不经常使用算法(LFU, Least Frequently Used) -- 为每一个Cache块设置一个"计数器", 用于记录每个Cache块被访问过几次. 当Cache满后替换"计数器"最小的

> 设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块{1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5}
> |访问主存块|1|2|3|4|1|2|5|1|2|3|4|5|
> |-|-|-|-|-|-|-|-|-|-|-|-|-|
> |Cache #0|1|1|1|1|1|1|1|1|1|1|1|1|
> |Cache #1||2|2|2|2|2|2|2|2|2|2|2|
> |Cache #2|||3|3|3|3|5|5|5|3|3|5|
> |Cache #3||||4|4|4|4|4|4|4|4|4|
> |Cache命中?|否|否|否|否|是|是|否|是|是|否|是|否|
> |Cache替换?|否|否|否|否|否|否|是|否|否|是|否|是|

新调入的块计数器=0, 之后每被访问一次计数器+1. 需要替换的时候, 选择计数器最小的一行

LFU算法 -- 曾经被经常访问的主存块在未来不一定会使用到(如: 微信视频聊天相关的块)并没有很好地遵循局部性原理, 因此实际运行效果不如LRU

## Cache写策略

### 写命中

#### 写回法(Write-back)

当CPU对Cache写命中时, 只修改Cache的内容, 而不立即写入主存, 只有当此块被换出时才写回主存. 可以增设一个标志位(脏位), 以反映此块是否被CPU修改过

减少了访问次数, 但有数据不一致的隐患

#### 全写法(Write-through)

当CPU对Cache写命中的时候, 必须把数据同时写入Cache和主存, 一般使用写缓冲(Write buffer)

访存次数增加, 速度变慢, 但更能保证数据一致性

使用写缓冲, CPU写的速度很快, 若写操作不频繁, 则效果很好. 若写操作很频繁, 可能会因为写缓冲饱和而发生阻塞. 写缓冲是一个FIFO队列, 写缓冲可以解决速度不匹配的问题.

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Cache%20write%20strategy1.png)

### 写不命中

#### 写分配法(Write-allocate)

当CPU对Cache写不命中的时候, 把主存中的块调入Cache, 在Cache中修改, 通常搭配写回法使用.

#### 非写分配法(Not-write-allocate)

当CPU对Cache写不命中时只写入主存, 不调入Cache, 搭配全写法使用

### 多级Cache

现代计算机多采用多级Cache
<br> 离CPU越近的速度越快, 容量越小
<br> 离CPU越远的速度越慢, 容量越大

各级Cache之间通常采用"全写法"+"非写分配法"
<br> Cache-主存之间常采用"写回法"+"写分配法"

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/Cache%20write%20strategy2.png)

## 页式存储器

### 页式存储

一个程序(进程)在逻辑上被分为若干个大小相等的"页面", "页面"的大小与"块"的大小相同. 每个页面可以离散地放入不同的主存块中

### 虚地址vs实地址

- 逻辑地址(虚地址): 程序员视角看到的地址
- 物理地址(实地址): 实际在主存中的地址

> 假设某程序4KB, 操作系统将该程序分为4页, 每页1KB, 要实现取变量x至ACC寄存器
> <br> 机器指令: 000001 001000000011(操作码+地址码, 使用逻辑地址)
> <br> 程序员视角: 整个程序一共4KB=2^12B, 地址范围: 000000000000~111111111111
> <br> 变量x的逻辑地址: 001000000011, 则应该被划分在0号页面中(逻辑页号若干位, 页内地址10位)
> <br> 主存的物理地址一共22位(主存块号12位, 块内地址10位), 变量x的物理地址: 000000000010 10000000011

### 页表: 逻辑页号->主存块号

> |逻辑页号|主存块号|
> |-|-|
> |#0|2|
> |#1|4094|
> |#2|0|
> |#3|4095|
> 
> 变量x的逻辑地址: 001000000011 变量x的物理地址: 000000000010 1000000011

CPU执行的机器指令中, 使用的是"逻辑地址", 因此需要通过"页表"将逻辑地址转化为"物理地址", 页表存储在主存里
<br> 页表的作用: 记录了每个逻辑页面存放在哪个主存块中

### 地址变换过程

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/page%20memory1.png)

### 地址变换过程(增加TLB)

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/IMG/page%20memory2.png)

注意TLB和Cache的区别: 快表中存储的是页表项的副本; Cache中存储的是主存块的副本

为什么快表很快? -- 因为快表是一种SRAM而内存是一种DRAM, 此外, 快表是一种"相联存储器", 可以按照内容寻访

### 访问过程

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Storage%20System/SVG/page%20memory3.drawio.svg)

# 第四章 指令系统

## 指令寻址

- 确定下一条要执行的指令的存放地址
- 由程序计数器PC指明

### 顺序寻址

(PC)+"1"->PC, 此处的"1"理解为1个指令字长, 每次取指令结束后, 一定会PC+"1"

> 系统采用变长指令字结构, 指令字长=存储字长=16bit=2B, 主存按照字节编址
> <br> 读入一个字, 根据操作码判断这条指令的总字节数n, 修改PC的值, (PC)+n->PC
> <br> 根据指令的类型, CPU可能还要进行多次访存, 每次读入一个字

### 跳跃寻址

执行转移类指令导致PC的值改变, 类似于无条件转移指令JMP等

## 数据寻址

形式地址, 简称为A; 真实地址, 简称为EA

> 假设指令字长=机器字长=存储字长, 操作数为3

### 直接寻址

指令字中的形式地址A就是操作数的真实地址EA, 即EA=A

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

优点: 简单, 指令执行阶段仅访问一次主存, 不需要专门计算操作数的地址

### 间接寻址

指令的地址字段给出的形式地址不是操作数真正的地址, 而是操作数有效地址所在的存储单元的地址, 也就是操作数地址的地址. 根据间接寻址的次数可以分为一次间接寻址和两次间接寻址

优点: 
- 可扩大寻址范围(有效寻址EA的位数大于形式地址A的位数)
- 便于编制程序(用间接寻址可以方便地完成子程序地返回)

### 寄存器寻址

在指令字中直接给出操作数所在地寄存器编号, 即EA=Ri, 其操作数在由Ri所指地寄存器内.

一次指令的执行: 
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 
- 指令在执行阶段不访问主存, 只访问寄存器
- 指令字短且执行速度快, 支持向量/矩阵运算

缺点: 寄存器价格昂贵, 计算机中寄存器的个数有限

### 寄存器简介寻址

寄存器Ri中给出的不是一个操作数, 而是操作数所在主存单元的地址, 即EA=(Ri)

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

特点: 与一般间接寻址相比速度更快, 但指令的执行阶段需要访问主存(因为操作数在主存中)

### 隐含寻址

隐含寻址: 不是明显地给出操作数的地址, 而是在指令中隐含着操作数的地址

优点: 有利于缩短指令字长

缺点: 需要增加存储操作数或者隐含地址的硬件

### 立即寻址

形式地址A就是操作数本身, 又称为立即数, 一般采用补码形式. #表示立即寻址特征

一条指令的执行:
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 指令执行阶段不访问主存, 指令执行时间最短

缺点: A的位数限制了立即数的范围

### 偏移寻址

#### 基址寻址

将CPU中基址寄存器(BR)中的内容加上指令格式中的形式地址A, 而形成操作数的有效地址, 即EA=(BR)+A

有两种方法:
1. 采用专用寄存器BR作为基址寄存器
2. 采用通用寄存器作为基址寄存器, 在指令中需要指明, 要将哪个通用寄存器作为基址寄存器使用, 一般用R0表示

优点: 便于程序"浮动", 方便实现多道程序并发运行

拓展: 程序运行前, CPU将BR的值修改为该程序的起始地址(存在操作系统PCB中)

注: 
- 基址寄存器是面向操作系统的, 其内容是由操作系统或者管理程序确定. 在程序执行过程中, 基址寄存器的内容不变(作为基地址), 形式地址可变(作为偏移量)
- 当采用通用寄存器作为基址寄存器时, 可由用户决定哪个寄存器作为基址寄存器, 但其内容仍由操作系统决定

#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和, 即EA=(IX)+A, 其中IX可为变址寄存器(专用), 也可用通用寄存器作为变址寄存器

注: 变址寄存器是面向用户的, 在程序执行的过程中, 变址寄存器的内容可由用户改变(IX作为偏移量), 形式地址A不变(作为基地址)

变址寻址作用: 在数组处理的过程中, 可设定A为数组的首地址, 不断改变变址寄存器IX的内容, 便可以很容易形成数组中任一数据的地址, 特别适合编制循环程序

#### 基址&变址复合寻址

- 基址寻址: EA=(BR)+A
- 变址寻址: EA=(IX)+A
- 先基址后变址寻址: EA=(IX)+(BX)+A

#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址, 即EA=(PC)+A, 其中A是相对于PC所指地址的位移量, 可正可负, 补码表示

注: 王道书上的小错误 -- "A是相当于当前指令地址的位移量"这句话是错误的, 因为取出当前指令后, PC+"1"指向的是下一条指令

优点: 操作数的地址不是固定的, 它随着PC的值的变化而变化, 并且与指令地址之间总是相差一个固定的值, 因此便于程序浮动(一段代码在程序内部的浮动), 相对寻址广泛用于转移指令

### 堆栈寻址

操作数放在堆栈中, 隐含使用堆栈指针(SP)作为操作数地址

堆栈是存储器(或专用寄存器组)中一块特定的按"后进先出(LIFO)"原则管理的存储区, 该存储区中被读/写单元的地址是用一个特定的寄存器给出的, 该寄存器称为堆栈指针(SP)

## CISC&RISC

### CISC和RISC

80-20规律: 典型程序中80%的语句仅仅使用处理机中20%的指令

#### CISC

CISC: Complex Instruction Set Computer

设计思路: 一条指令完成一个复杂的基本功能

代表: X86架构, 主要用于笔记本, 台式机等

> 比如设计一套能实现整数, 矩阵加/减/乘运算的指令集
> <br> CISC的设计思路: 除了提供整数的加减乘指令除之外, 还提供矩阵的加法指令, 矩阵的减法指令, 矩阵的乘法指令.
> <br> 一条指令可以由一个专门的电路完成
> <br> 有的复杂指令用纯硬件实现很困难, 采用"存储程序"的设计思想, 由一个比较通用的电路配合存储部件完成一条指令

#### RISC

设计思路: 一条指令完成一个基本"动作"; 多条指令组合完成一个复杂的基本功能

代表: ARM架构, 主要用于手机, 平板等

> 比如设计一套能实现整数, 矩阵加/减/乘运算的指令集
> <br> RISC的思路: 只提供整数的加减乘指令
> <br> 一条指令一个电路, 电路设计相对简单, 功耗更低

### 区别

|                    | CISC                                 | RISC                                 |
| ------------------ | ------------------------------------ | ------------------------------------ |
| 指令系统           | 复杂, 庞大                           | 简单, 精简                           |
| 指令数目           | 一般大于200条                        | 一般小于100条                        |
| 指令字长           | 不固定                               | 定长                                 |
| 可访存指令         | 不加限制                             | 只有Load/Store指令                   |
| 各种指令执行时间   | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令的使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量     | 较少                                 | 多                                   |
| 目标代码           | 难以用优化编译生成搞笑的目标代码程序 | 采用优化的编译程序, 生成代码较为高效 |
| 控制方式           | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线         | 可以通过一定方式实现                 | 必须实现                             |

# 第五章 中央处理器

## CPU的功能和基本结构

### CPU的功能

1. 指令控制: 完成取指令, 分析指令和执行指令的操作, 即程序的顺序控制
2. 操作控制: 一条指令的功能往往是若干操作信号的组合来实现的. CPU管理并产生由内存取出的每条指令的操作信号. 把各种操作信号送往响应的部件, 从而控制这些部件按指令的要求进行动作
3. 时间控制: 对各种操作加以时间上的控制. 时间控制要为每条指令按照时间顺序提供应有的控制信号
4. 数据加工: 对数据进行算术和逻辑运算
5. 中断处理: 对计算机运行过程中出现的异常情况和特殊请求进行处理

### 运算器和控制器的功能

#### 运算器

对数据进行加工

#### 控制器

协调并控制计算机各部件执行程序的指令序列, 基本功能包括取指令, 分析指令, 执行指令
- 取指令: 自动形成指令地址; 自动发出取指令的命令
- 分析指令: 操作码译码(分析本条指令要完成什么操作); 产生操作数的有效地址
- 执行指令: 根据分析指令得到的"操作命令"和"操作数地址", 形成操作信号控制序列, 控制运算器, 存储器以及I/O设备完成响应的操作
- 中断指令: 管理总线几输入输出; 处理异常情况(如掉电)和特殊请求(如打印机请求打印一行字符)

### 运算器的基本结构

- 算术逻辑单元: 主要功能是进行算术/逻辑运算
- 通用寄存器组: 如AX、BX、CX、DX、SP等, 用于存放操作数(包括源操作数、目的操作数及中间结果)和各种地址信息. SP是堆栈指针, 用于指示栈顶的地址(stack pointer)
- 暂存器: 用于暂存从主存读出来的数据, 这个数据不能存放在通用寄存器中, 否则会破坏其原有的内容
- 累加寄存器: 它是一个通用寄存器, 用于暂时存放ALU运算的结果信息, 用于实现加法运算
- 程序状态字寄存器: 保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息, 如溢出标志(OP)、符号标志(SF)、零标志(ZF)、进位标志(CF)等. PSW中的这些位参与并决定微操作的形成
- 移位器: 对运算结果进行移位运算
- 计数器: 控制乘除运算的操作数

#### 专用数据通路方式

根据指令执行过程中的数据和地址的流动方向安排链接线路

如果直接用导线连接, 相当于多个寄存器同时并且一直向ALU传输数据
- 解决方法1: 使用多路选择器, 根据控制信号选择一路输出
- 解决方法2: 使用三态门, 可以控制每一路是否输出

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/9e72d526e2286b0a405a6ddfd39568cf493e8453/Computer-Organization%20WD/CPU/Function%20and%20basic%20structure%20of%20CPU.md)

性能较高, 基本不存在数据冲突现象, 但是结构复杂, 硬件量大, 不易实现

#### CPU内部单总线方式

将所有寄存器的输入端和输出端都连接到一条公共的通路上

![]()

### 控制器的基本结构

- 程序计数器: 用于指出下一条指令在主存中的存放地址. CPU就是根据PC的内容去主存中读取指令的. 因程序中指令(通常)是顺序执行的, 所以PC有自增功能
- 指令寄存器: 用于保存当前正在执行的指令
- 指令译码器: 仅对操作码字段进行译码, 向控制器提供特定的操作信号
- 微操作信号发生器: 根据IR的内容(指令)、PSW的内容(状态信息)及时序信号, 产生控制整个计算机系统所需的各种控制信号, 其结构有组合逻辑型和存储逻辑型两种
- 时序系统: 用于产生各种时序信号, 他们都是由统一时钟(CLOCK)分频得到
- 存储器地址寄存器: 用于存放所要访问的主存单元的地址

![]()

### CPU的基本结构

- ALU
- 中断系统
- 寄存器
- CU

## 指令执行过程

### 指令周期

指令周期: CPU从主存中每取出并执行一条指令所花的全部时间
</br> 指令周期常常用若干机器周期来表示, 机器周期又叫CPU周期
</br> 一个机器周期又包含若干时钟周期(也称为节拍、T周期或者CPU时钟周期, 它是CPU操作的最基本单位)

每个指令周期内机器周期数可以不等, 每个机器周期内的节拍数也可以不等, 如: 
> 空指令NOP: 取址周期
> </br> 加法指令ADD: 取址周期+执行周期
> </br> 取址周期+较长的执行周期
> </br> 取址周期+间接寻址周期+执行周期
> </br> 取址周期+间接寻址周期+执行周期+中断周期

### 指令周期流程

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/CPU/SVG/instruction%20execution%20process1.drawio.svg)

四个工作周期都有CPU访存操作, 只是访存的目的不同. 取址周期是为了取指令, 间址周期是为了取有效地址, 执行周期是为了取操作数, 中断周期是为了保存程序断点

### 指令周期的数据流—取址周期

1. 当前指令地址送至存储器地址寄存器, 记做: (PC)->MAR
2. CU发出控制信号, 经控制总线传到主存, 这里是读信号, 记做: 1->R
3. 将MAR所指主存中的内容经数据总线送入MDR, 记做M(MAR)->MDR
4. 将MDR中的内容(此时是指令)送入IR, 记做: (MDR)->IR
5. CU发出控制信号, 形成下一条指令地址, 记做: (PC)+1->PC

### 指令周期的数据流-间址周期

1. 将指令的地址码放入MAR, 记做: Ad(IR)->MAR或者是Ad(MDR)->MAR
2. CU发出控制信号, 启动主存读操作, 记做: 1->R
3. 将MAR所指主存中的内容经过数据总线送入MDR, 记做: M(MAR)->MDR
4. 将有效地址送至指令的地址码字段, 记做: (MDR)->Ad(IR)

### 指令周期的数据流-执行周期

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果. 不同指令的执行周期操作数不同, 因此没有统一的数据流向

### 指令周期的数据流-中断周期

暂停执行当前的程序去执行其他的程序. 为了能够恢复当前任务, 需要保存断点. 一般用堆栈来保存断点, 这里用SP表示栈顶地址, 假设SP指向栈顶元素, 进栈操作是先修改指针, 后存入数据.

中断周期中的进栈操作是将SP减1, 这和传统意义上的进栈操作相反, 原因是计算机的堆栈中都是向低地址增加, 所以进栈操作是减1而不是加1

1. CU控制将SP-1, 修改后的地址送入MAR, 记做: (SP)-1->SP, (SP)->MAR. 本质上是将断点存入某个存储单元, 假设其地址为a, 故可以记做: a->MAR
2. CU发出控制信号, 启动主存做写操作, 记做: 1->w
3. 将断点(PC内容)送入MDR, 记做(PC)->MDR
4. CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入PC, 记做: 向量地址->PC

### 指令执行方案

一个指令周期通常包括几个时间段(执行步骤), 每个步骤完成指令的一部分功能, 几个依次执行的步骤完成这条指令的全部功能

#### 单指令周期

对所有指令选用相同的执行时间来完成, 指令之间串行执行, 指令周期取决于执行时间最长的指令的执行时间

#### 多指令周期

对于不同类型的指令选用不同的执行步骤来完成. 指令之间串行执行; 可选用不同个数的时钟周期来完成不同指令的执行过程

#### 流水线方案

在每一个时钟周期启动一条指令, 尽量让多条指令同时运行, 但各自处在不同的执行步骤中, 指令之间并行执行

## 数据通路的功能&单总线结构

### 数据通路

数据通路的基本结构: 
1. CPU内部单总线方式
2. CPU内部多总线方式
3. 专用数据通路方式

### 数据通路-CPU内部单总线方式

- 内部总线是指同一部件, 如CPU内部连接各个寄存器及运算部件之间的总线
- 系统总线是指同一台计算机系统的各部件, 如CPU、内存、通道和各类I/O接口之间互相连接的总线

#### 寄存器之间的数据传送

比如把PC内容送至MAR, 实现传送操作的流程及控制信号为:
</br> (PC)->Bus PCout有效, PC内容送总线
</br> Bus->MAR MARin有效, 总线内容送MAR
</br> 重要的是描述清楚数据的流向

#### 主存与CPU之间的数据传送

比如CPU从主存读取指令, 实现传送操作的流向及控制信号为: 
</br> (PC)->Bus->MAR PCout和MARin有效, 现行指令地址->MAR
</br> 1->R CU发读命令(通过控制总线发出)
</br> MEM(MAR)->MDR 指令从存储器->数据线->MDR
</br> MDR->Bus->IR MDRout和IRin有效, 现行指令->IR

#### 执行算术或者逻辑运算

比如一条加法指令, 微操作序列及控制信号为: 
</br> Ad(IR)->Bus->MAR MDRout和MARin有效
</br> 1->R CU发出读命令
</br> MEM(MAR)->数据线->MDR 操作数从存储器->数据线->MDR
</br> MDR->Bus->Y MDRout和Yin有效, 操作数->Y
</br> (ACC)+(Y)->Z ACCout和ALUin有效, CU向ALU发送加命令
</br> Z->ACC Zout和ACCin有效, 结果->ACC

### 公共操作

| 时序 | 微操作       | 有效控制信号         |
| ---- | ------------ | -------------------- |
| 1    | (PC)->MAR    | PCout, MARin         |
| 2    | M(MAR)->MDR  | MemR, MARout, MDRinE |
| 3    | (MDR)->IR    | MDRout, IRin         |
| 4    | 指令译码     | -                    |
| 5    | (PC)+1->(PC) | -                    |

## 数据通路专用通路结构

### 专用数据通路方式-取指周期

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/CPU/Data%20Path%20Dedicated%20Path%20Structure.md)

1. (PC)->MAR C0有效
2. (MAR)->主存 C1有效
3. 1->R 控制单元向主存发送读命令
4. M(MAR)->MDR C2有效
5. (MDR)->IR C3有效
6. (PC)+1->PC
7. Op(IR)->CU C4有效

## 控制器设计硬布线控制器

### 内容回顾

每一个机器周期由若干个时钟周期(或者称为节拍)组成, 通过若干个微操作组成的序列完成这个周期内需要做的事情. CU会在每一个节拍内, 发出一个微命令, 用来完成对应的微操作. 如: 微命令1使得PCout和MARin有效, 则完成对应的微操作1(PC)->MAR

> - 取址周期(FE=1): T0: 微操作1、微操作2; T1: 微操作3; T2: 微操作4;
> - 间址周期(IND=1): T0: 微操作5、微操作2; T1: 微操作6; T2: 微操作7;
> - 执行周期(EX=1): T0: 无; T1: 微操作8; T2: 微操作9、微操作6
> - 中断周期(INT=1): T0: 无; T1: 微操作10; T2: 微操作11

- 一个节拍内可以并行完成多个“相容的”微操作
- 同一个微操作可能在不同指令的不同阶段内被使用
- 不同指令的执行周期所需节拍数各不相同, 为了简化设计, 选择定长的机器周期, 以可能出现的最大节拍数为准(通常以访存所需的节拍数为参考)
- 若实际所需的节拍数较少, 可将微操作安排在机器周期末尾几个节拍上进行
- 根据指令操作码、目前的机器周期、节拍信号、机器状态条件, 即可确定现在这个节拍下应该发出哪些“微指令”

### 硬布线控制器

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/CPU/SVG/Controller%20Design%20Hardwired%20Controller1.svg)

所有指令的取址周期、T0节拍下一定要完成(PC)->MAR. 则可知C1=FE∙T0 逻辑表达式是电路的数学化描述

> M(MAR)->MDR微操作命令的逻辑表达式: FE∙T1+IND∙T1(ADD+STA+LDA+JMP+BAN)+EX∙T1(ADD+LDA)

### 硬布线控制器的设计

设计步骤: 
1. 分析每个阶段的微操作序列(取指令、间指、执行、中断四个阶段)「确定哪些指令在什么阶段、在什么条件下会使用到什么微操作」
2. 选择CPU的控制方式「采用定长机器后期还是不定长机器周期?每个机器周期安排几个节拍?」
3. 安排微操作的时序「如何用3个节拍完成整个机器周期内的所有微操作」
4. 电路设计

特点: 
</br> 指令越多, 设计和实现就越复杂, 因此一般用于RISC(精简指令集系统), 如果扩充一条新的指令, 则控制器的设计就需要大改, 因此扩充指令较困难, 由于使用纯硬件实现控制, 因此执行速度更快, 微操作控制信号由组合逻辑电路即时产生

#### 分析每个阶段的微操作序列

- 取址周期(所有的指令都一样): PC->MAR; 1->R; M(MAR)->MDR; MDR->IR; OP(IR)->ID; (PC)+1->PC (ID为指令译码器 Instruction Decoder)
- 间址周期(所有指令都一样): Ad(IR)->MAR; 1->R; M(MAR)->MDR; MDR->Ad(IR)
- 执行周期(各不相同): 
  - CLA: clear ACC指令 ACC清零 0->AC(很多地方将ACC简写为AC)
  - LDA: 取数指令, 把x所指内容取到ACC Ad(IR)->MAR; 1->R; M(MAR)-> MDR; MDR->AC
  - JMP: 无条件转移 Ad(IR)->PC
  - BAN: 条件转移, 当ACC为负时转移 A0∙Ad(IR)+(1-A0)∙(PC)->PC

罗列出所有指令在各个阶段的微操作序列, 就可以知道在什么情况下需要使用这个微操作

#### 选择CPU的控制方式

假设采用同步控制方式(定长机器周期), 一个机器周期内安排3个节拍

#### 安排微操作时序

三个原则: 
- 微操作的先后顺序不得随意更改
- 被控对象不同的微操作尽量安排在一个节拍内进行
- 占用时间较短的微操作, 尽量安排在一个节拍内完成, 并允许有先后顺序

##### 取址周期

1. T0: PC->MAR, 1->R
2. T1: M(MAR)->MDR, (PC)+1->PC
3. T2: MDR->IR, OP(IR)->ID

- M(MAR)->MDR: 从主存取数据, 用时较长, 因此必须一个时钟周期才能保证微操作的完成
- MDR->IR: 是CPU内部寄存器的数据传送, 速度很快, 因此在一个时钟周期内可以紧接着完成OP(IR)->ID, 也就是可以一次同时发出两个微命令

##### 间址周期

1. T0: Ad(IR)->MAR, 1->R
2. T1: M(MAR)->MDR
3. T2: MDR->Ad(IR)

#### 电路设计

参见书表

可以得出微操作命令的逻辑表达式
