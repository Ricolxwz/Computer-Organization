## 数据寻址

形式地址, 简称为A; 真实地址, 简称为EA

> 假设指令字长=机器字长=存储字长, 操作数为3

### 直接寻址

指令字中的形式地址A就是操作数的真实地址EA, 即EA=A

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

优点: 简单, 指令执行阶段仅访问一次主存, 不需要专门计算操作数的地址

### 间接寻址

指令的地址字段给出的形式地址不是操作数真正的地址, 而是操作数有效地址所在的存储单元的地址, 也就是操作数地址的地址. 根据间接寻址的次数可以分为一次间接寻址和两次间接寻址

优点: 
- 可扩大寻址范围(有效寻址EA的位数大于形式地址A的位数)
- 便于编制程序(用间接寻址可以方便地完成子程序地返回)

### 寄存器寻址

在指令字中直接给出操作数所在地寄存器编号, 即EA=Ri, 其操作数在由Ri所指地寄存器内.

一次指令的执行: 
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 
- 指令在执行阶段不访问主存, 只访问寄存器
- 指令字短且执行速度快, 支持向量/矩阵运算

缺点: 寄存器价格昂贵, 计算机中寄存器的个数有限

### 寄存器简介寻址

寄存器Ri中给出的不是一个操作数, 而是操作数所在主存单元的地址, 即EA=(Ri)

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

特点: 与一般间接寻址相比速度更快, 但指令的执行阶段需要访问主存(因为操作数在主存中)

### 隐含寻址

隐含寻址: 不是明显地给出操作数的地址, 而是在指令中隐含着操作数的地址

优点: 有利于缩短指令字长

缺点: 需要增加存储操作数或者隐含地址的硬件

### 立即寻址

形式地址A就是操作数本身, 又称为立即数, 一般采用补码形式. #表示立即寻址特征

一条指令的执行:
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 指令执行阶段不访问主存, 指令执行时间最短

缺点: A的位数限制了立即数的范围

### 偏移寻址

#### 基址寻址

将CPU中基址寄存器(BR)中的内容加上指令格式中的形式地址A, 而形成操作数的有效地址, 即EA=(BR)+A

有两种方法:
1. 采用专用寄存器BR作为基址寄存器
2. 采用通用寄存器作为基址寄存器, 在指令中需要指明, 要将哪个通用寄存器作为基址寄存器使用, 一般用R0表示

优点: 便于程序"浮动", 方便实现多道程序并发运行

拓展: 程序运行前, CPU将BR的值修改为该程序的起始地址(存在操作系统PCB中)

注: 
- 基址寄存器是面向操作系统的, 其内容是由操作系统或者管理程序确定. 在程序执行过程中, 基址寄存器的内容不变(作为基地址), 形式地址可变(作为偏移量)
- 当采用通用寄存器作为基址寄存器时, 可由用户决定哪个寄存器作为基址寄存器, 但其内容仍由操作系统决定

#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和, 即EA=(IX)+A, 其中IX可为变址寄存器(专用), 也可用通用寄存器作为变址寄存器

注: 变址寄存器是面向用户的, 在程序执行的过程中, 变址寄存器的内容可由用户改变(IX作为偏移量), 形式地址A不变(作为基地址)

变址寻址作用: 在数组处理的过程中, 可设定A为数组的首地址, 不断改变变址寄存器IX的内容, 便可以很容易形成数组中任一数据的地址, 特别适合编制循环程序

#### 基址&变址复合寻址

- 基址寻址: EA=(BR)+A
- 变址寻址: EA=(IX)+A
- 先基址后变址寻址: EA=(IX)+(BX)+A

#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址, 即EA=(PC)+A, 其中A是相对于PC所指地址的位移量, 可正可负, 补码表示

注: 王道书上的小错误 -- "A是相当于当前指令地址的位移量"这句话是错误的, 因为取出当前指令后, PC+"1"指向的是下一条指令

优点: 操作数的地址不是固定的, 它随着PC的值的变化而变化, 并且与指令地址之间总是相差一个固定的值, 因此便于程序浮动(一段代码在程序内部的浮动), 相对寻址广泛用于转移指令