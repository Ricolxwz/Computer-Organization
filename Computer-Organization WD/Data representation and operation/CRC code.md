## 循环冗余校验码

### 基本思想

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code1.png)

数据发送、接受方约定一个“除数”, K个信息位+R个校验位作为“被除数”, 添加校验位后需要保证除法的余数为0. 收到数据后, 进行除法检查余数是否为0. 若余数非0说明出错, 则进行重传或者纠错

### 步骤

#### 移位

将原信息码左移R位, 低位补0

#### 相除

- 对移位后的信息码, 用生成的多项式进行模2除法, 产生余数, 得到的余数就是校验码
- 模2除法: 模2加法和模2减法的结果相同, 都是异或运算. 模2除法和算数除法类似, 但每位除(减)的结果不影响其他位, 步骤如下: ①用除数对被除数最高几位做模2减运算(异或)不错位; ②除数右移1位, 若余数的最高位为1, 商为1, 并对余数做模2减运算. 若余数最高位为0, 商为0, 余数继续右移1位; ③ 循环直到余数位数小于余数时, 该余数为最终余数.

#### 检错和纠错

- 将接收端收到的CRC码, 用生成多项式G(x)做模2除法, 若余数为0, 则码字无错
- K个信息位, R个校验位, 若生成多项式选择得当, 且$2^R≥K+R+1$, 则CRC码可以纠正1位错(无法纠正的情况, 看下面例子)
- 在实际应用当中, 这种校验码一般只用来检错, 因为信息位实在是太长了
- 理论上可以证明循环冗余校验码的检错能力有以下几点:
  - 可检测出所有奇数个错误
  - 可检测出所有双比特的错误
  - 可检测出所有小于等于校验长度的连续错误

> Q: 设生成多项式为$G(x)=x^3+x^2+1$, 信息码为101001, 求对应的CRC码
> <br> R=生成多项式的最高幂次=3, K=信息码的长度=6, N=K+R=9
> <br> 生成多项式G(x)对应的二进制码为1101
> 1. 移位
> <br> 将原信息码左移R位, 低位补0, 得到了101001000
> 2. 相除
> <br> ![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code2.png)
> <br> 最终得到的余数为001, 则CRC码为101001001
> 3. 检错和纠错
> <br> 发送: 101001001 记为C9C8C7C6C5C4C3C2C1
> <br> 接收: 101001001 用1101进行模2除 余数为000, 代表没有出错
> <br> 接收: 101001011 用1101进行模2除 余数位010, 代表C2出错
> <br>
> <br> 注意: 余数为010并不一定代表C2出错
> <br> ![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/IMG/CRC%20code3.png)
> <br> 3个bit位最多只能表示8种状态(注意这里的出错位不是余数二进制转十进制!), 000表示正确状态. 从表中可以看出, 如果第9位出错的话, 余数也为010. 但不能说CRC码没有纠错能力, 只是本例中的信息位太长