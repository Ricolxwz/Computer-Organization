## 浮点数的表示和运算

### 从科学计数法理解浮点数

![](https://github.com/Ricolxwz/Computer-Organization-408/blob/main/Computer-Organization%20WD/Data%20representation%20and%20operation/SVG/Representation%20and%20operation%20of%20floating%20point%20numbers1.drawio.svg)

### 浮点数的表示

- 浮点数的真值: $N=r^E\times M$
- 阶码E: 常用补码或者移码表示的定点整数, 通常阶码的底是2
- 尾数M: 常用原码或者补码表示的定点小数, 数值部分的位数n反映浮点数的精度
- 尾数给出一个小数, 阶码指明了小数点要向前/向后移动几位
- 尾数的最高位是无效值, 会丧失精度

> 阶码, 尾数均用补码表示, 求a, b的真值
> <br> a=0,01; 1.1001
> <br> b=0,10; 0.10001
> <br> a: 阶码0,01对应真值+1; 尾数1.1001对应真值-0.0111=-(2^-2+2^-3+2^-4)
> <br> a的真值=2^1*(-0.0111)=-0.111, 相当于尾数表示的定点小数算数左移一位, 或小数点右移一位
> <br> b: 阶码0,10对应的真值位+2; 尾数0.01001对应的真值+0.01001=+(2^-2+2^-5)
> <br> b的真值=2^2*(+0.01001)=+1.001

### 浮点数尾数的规格化

规格化浮点数: 规定尾数的最高数值位必须是一个有效值

- 左规: 当浮点数运算结果为非规格化时要进行规格化处理
- 右规: 当浮点数运算的结果尾数出现溢出(双符号位为01或者10)时, 将尾数算数右移一位, 阶码加1

> a=010;00.1100, b=010;00.1000, 求a+b
> <br> a=2^2*00.1100, b=2^2*00.1000
> <br> a+b=2^2*00.1100+2^2*00.1000=2^2*(00.1100+00.1000)=2^2*01.0100=2^3*00.1010(发现溢出)

采用"双符号位", 当溢出发生的时候, 可以挽救. 更高的符号位是正确的符号位

### 规格化浮点数的特点

#### 用原码表示的尾数的规格化

- 正数为0.1XX...X的形式, 其最大值表示为0.11...1; 最小值表示为0.10...0
  - 尾数的表示范围为0.5≤M≤(1-2^(-n))
- 负数为1.1XX...X的形式, 其最大值表示为1.10...0, 最小值表示为1.11...1
  - 尾数的表示范围为-(1-2^(-n))≤M≤-0.5

#### 用补码表示的尾数进行格式化

- 正数为0.1XX...X的形式, 其最大值表示为0.11...1; 最小值表示为0.10...0
  - 尾数的表示范围为0.5≤M≤(1-2^(-n))
- 负数为1.0XX...X的形式, 其最大值表示为1.01...1; 最小值表示为1.00...0
  - 尾数的表示范围为-1≤M≤-(1/2+2^(-n))

> 若某浮点数的阶码, 尾数用补码表示, 共4+8位: 0,110; 1.1110100如何规格化?
> <br> 应该将数值部分左移3位, 并将阶码从+6变成+3. 
> <br> 补码算数左移, 低位补0; 补码算数右移, 高位补1.

