## 浮点数的运算

### 浮点数的加减运算

> 9.85211*10^12+9.96007*10^10

#### 对阶

> 9.85211*10^12+0.0996007*10^12

为何小阶向大阶对齐?
<br> 因为在计算机内部, 尾数是定点小数

#### 尾数相减

> 9.9517107*10^12

#### 规格化

> 如果尾数加减出现类似0.定点9517*10^12时, 需要"左规"; 如果尾数加减出现类似99.517107*10^12时, 需要"右规"

#### 舍入

> 若规定只能保留6位有效尾数, 则9.9517107*10^12 -> 9.95171*10^12 (多余的直接砍掉); 或者, 9.9517107*10^12 -> 9.95172*10^12(若砍掉部分非0, 则入1); 或者, 也可以采用四舍五入的原则, 当舍弃位≥5时, 高位入1

#### 判断溢出

> 若规定阶码不能超过两位, 则运算后阶码超出范围, 则溢出. 如:9.85211*10^99+9d.96007*10^99=19.81218*10^99, 规格化并用四舍五入的原则保留6位尾数, 得1.98122*10^100. 阶码超过两位, 发生溢出(注: 尾数溢出未必导致整体溢出, 也许可以通过③④两步来拯救)

### 加减运算示例

> 已知十进制数X=-5/256, Y=59/1024, 按机器补码浮点运算规则计算X-Y, 结果用二进制表示, 浮点数格式如下: 阶符取2位, 阶码取3位, 数符取2位, 尾数取9位
> <br> 用补码表示阶码和尾数: 5D=101B, 1/256=2^(-8)->X=-101*2^(-8)=-0.101*2^(-5)=-0.101*2^(-101); 59D=111011B, 1/1024=2^(-10)->Y=+111011*2^(-10)=+0.111011*2^(-4)=+0.111011*2^(-100)
> <br> X的阶码双符号位补码: 11011; 尾数双符号位补码并扩展: 11.011000000; Y的阶码和尾数自己算. 最终得到X: 11011,11.011000000; Y: 11100,00.111011000
> 