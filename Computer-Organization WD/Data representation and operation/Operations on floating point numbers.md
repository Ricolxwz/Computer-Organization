## 浮点数的运算

### 浮点数的加减运算

> 9.85211*10^12+9.96007*10^10

#### 对阶

> 9.85211*10^12+0.0996007*10^12

为何小阶向大阶对齐?
<br> 因为在计算机内部, 尾数是定点小数

#### 尾数相减

> 9.9517107*10^12

#### 规格化

> 如果尾数加减出现类似0.定点9517*10^12时, 需要"左规"; 如果尾数加减出现类似99.517107*10^12时, 需要"右规"

#### 舍入

> 若规定只能保留6位有效尾数, 则9.9517107*10^12 -> 9.95171*10^12 (多余的直接砍掉); 或者, 9.9517107*10^12 -> 9.95172*10^12(若砍掉部分非0, 则入1); 或者, 也可以采用四舍五入的原则, 当舍弃位≥5时, 高位入1

#### 判断溢出

> 若规定阶码不能超过两位, 则运算后阶码超出范围, 则溢出. 如:9.85211*10^99+9d.96007*10^99=19.81218*10^99, 规格化并用四舍五入的原则保留6位尾数, 得1.98122*10^100. 阶码超过两位, 发生溢出(注: 尾数溢出未必导致整体溢出, 也许可以通过③④两步来拯救)

### 加减运算示例

> 已知十进制数X=-5/256, Y=59/1024, 按机器补码浮点运算规则计算X-Y, 结果用二进制表示, 浮点数格式如下: 阶符取2位, 阶码取3位, 数符取2位, 尾数取9位
> <br> 用补码表示阶码和尾数: 5D=101B, 1/256=2^(-8)->X=-101*2^(-8)=-0.101*2^(-5)=-0.101*2^(-101); 59D=111011B, 1/1024=2^(-10)->Y=+111011*2^(-10)=+0.111011*2^(-4)=+0.111011*2^(-100)
> <br> X的阶码双符号位补码: 11011; 尾数双符号位补码并扩展: 11.011000000; Y的阶码和尾数自己算. 最终得到X: 11011,11.011000000; Y: 11100,00.111011000
> 
> 1. 对阶: 使两个数的阶码相等, 小阶向大阶看齐, 尾数每右移一位, 阶码+1. 求阶差: [∆E]补=11011+00100=11111, 知∆E=-1; 对阶: X: 11011,11.011000000 -> 11100,11.101100000
> 2. 尾数加减: -Y: 11100,11.000101000; X-Y=: 11100,10.110001000, 由双符号位得出发生溢出, 但是可以通过规格化拯救溢出
> 3. 规格化: X-Y: 11100, 10.110001000 -> 11101, 11.011000100
> 4. 舍入: 无舍入
> 5. 判断溢出: 常阶码, 无溢出, 结果真值为2^(-3)*(-0.1001111)2

### 浮点数的加减运算-舍入

#### "0"舍"1"入法

类似于十进制数运算中的"四舍五入"法, 即在尾数右移的时候, 被移去的最高位数值为0, 则舍去; 被移去的最高位数值为1, 则在尾数的末位加1. 这样做可能会使尾数又溢出, 此时需要再做一次右规

#### 恒置"1"法

尾数右移的时候, 不论丢掉的最高数值位是"1"还是"0", 都使右移后的尾数末位恒置"1". 这种方法同样有使尾数变大和变小的两种可能

### 强制类型转换

| 类型      | 16位机器 | 32位机器 | 64位机器 |
| --------- | -------- | -------- | -------- |
| char      | 8        | 8        | 8        |
| short     | 16       | 16       | 16       |
| int       | 16       | 32       | 32       |
| long      | 32       | 32       | 64       |
| long long | 64       | 64       | 64       |
| float     | 16       | 32       | 32       |
| double    | 64       | 64       | 64       |

- char -> int -> long -> double: 如果long是32bit的话, 则long转换为double为无损转化. 如果long是64bit的话, 则long转化为double为有损转换, 因为double的有效数值位只有53位
- float -> double: 不会损失精度

#### 32位int和float

- int: 表示整数, 1位符号位+31位数值位, 范围-2^(31)~2^(31)-1, 有效数字32位
- float: 表示整数及小数, 范围±[2^(-126)~2^(127)*(2-2^(-23))], 1位符号位8个阶码23个尾数, 有效数字23+1=24位

1. int -> float: 可能损失精度
2. float -> int: 可能溢出及损失精度(小数转化为小数的时候)