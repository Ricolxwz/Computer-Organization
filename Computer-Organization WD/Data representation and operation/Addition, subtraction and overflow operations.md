## 加减运算和溢出运算

### 原码的加减运算

加法器直接对原码进行加法运算, 可能出错, 需要用减法器实现

原码的加法运算:
<br> 正+正 -> 绝对值做加法, 结果为正
<br> 负+负 -> 绝对值做加法, 结果为负
<br> 正+负 -> 绝对大的减绝对值小的, 符号同绝对值大的数
<br> 负+正 -> 绝对值大的减绝对值小的, 符号同绝对值大的数

原码的减法运算, "减数"符号取反, 转变为加法:
<br>  正-负 -> 正+正
<br> 负-正 -> 负+负
<br> 正-正 -> 正+负
<br> 负+正 -> 负-负

### 补码的加减运算

对于补码来说, 无论加法还是减法, 最后都会转变为加法, 由加法器实现运算, 符号位也参与运算

#### 负数补码转化为原码的方式

- 数值位取反+1
- 负数补码中, 最右边的1及其右边同原码. 最右边的1的左边同反码

#### 溢出判断

> 设机器的字长为8位(含1位符号位), A=15, B=-24
> <br> C=124, 求[A+C]补和[B-C]补
> <br> [A+C]补=0,000111+0,1111100=1,0001011 真值-117
> <br> [B-C]补=1,1101000+1,0000100=0,1101100 真值+108

- 只有"正数+正数"才会上溢--正+正=负
- 只有"负数+负数"才会下溢--负+负=正

##### 方法一 采用一位符号位

采用一位符号位, 设A的符号为As, B的符号为Bs, 运算结果的符号为Ss, 则溢出逻辑表达式为$V=A_sB_s\overline{S_s}+\overline{A_s}\overline{B_s}S_s$

若V=0, 表示无溢出
<br> 若V=1, 表示有溢出

溢出的两种情况: 
<br> As为1且Bs为1且Ss为0
<br> As为0且Bs为0且Ss为1

##### 方法二 采用一位符号位根据数据位的进位情况判断溢出

采用一位符号位, 根据数据位进位情况判断溢出

|      | 符号位的进位Cs | 最高数值位的进位C1 |
| ---- | -------------- | ------------------ |
| 上溢 | 0              | 1                  |
| 下溢 | 1              | 0                  |

即: Cs与C1不同时有溢出
<br> 处理不同的逻辑符号: 异或⊕
<br> 溢出逻辑判断表达式为V=Cs⊕C1
<br> 若V=0, 表示无溢出; V=1, 表示有溢出

##### 方法三 采用双符号位

正数符号为00, 负数符号为11

记两个符号位为Ss1,Ss2, 则V=Ss1⊕Ss2
<br> 若V=0, 表示无溢出; 若V=1, 表示有溢出

双符号位补码又称: 模4补码
单符号位补码又称: 模2补码

### 符号扩展

#### 正整数

> 01011010 -> 0000000001011010

#### 负整数

> ||转换前|转换后|
> |-|-|-|
> |原码|11011010|1000000001011010|
> |反码|10100101|1111111110100101|
> |补码|10100110|1111111110100110|

#### 正小数

> 0.1011010 -> 0.101101000000000

#### 负小数

> ||转换前|转换后|
> |-|-|-|
> |原码|1.1011010|1.101101000000000|
> |反码|1.0100101|1.010010111111111|
> |补码|1.0100110|1.010011000000000|

- 定点整数的符号扩展: 在原符号位和数值位中间添加新位, 正数都添0; 负数原码添0, 负数反, 补码添1
- 定点小数的符号扩展: 在原符号位和数值位后面添加新的位, 正数都添0; 负数原, 补码添0, 负数反码添1